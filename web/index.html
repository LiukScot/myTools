<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>myHealth CSV Importer</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #000000;
      --panel: #0b0b0d;
      --card: #1f1f23;
      --card-strong: #26262b;
      --accent: #ff5e8a;
      --accent-2: #ff8fb1;
      --text: #f5f5f7;
      --muted: #a1a1ad;
      --border: #35353b;
      --danger: #ff5a7f;
      --shadow: 0 20px 55px rgba(0,0,0,0.5);
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Manrope", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background:
        radial-gradient(140% 120% at 20% 10%, rgba(255,94,138,0.14), rgba(0,0,0,0)),
        radial-gradient(120% 100% at 80% 5%, rgba(255,143,177,0.08), rgba(0,0,0,0)),
        var(--bg);
      background-repeat: no-repeat;
      background-size: cover;
      background-attachment: fixed;
      color: var(--text);
    }
    .shell {
      max-width: 1200px;
      margin: 0 auto;
      padding: 32px 20px 48px;
    }
    header { margin-bottom: 18px; }
    .title {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      font-size: 26px;
      font-weight: 700;
      letter-spacing: -0.02em;
    }
    .heart {
      width: 24px;
      height: 24px;
      border-radius: 8px;
      background: radial-gradient(circle at 30% 30%, #ff5e8a, #ff8fb1);
      display: grid;
      place-items: center;
      color: #fff;
      font-size: 14px;
      box-shadow: 0 10px 25px rgba(255,94,138,0.35);
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      gap: 18px;
      margin-bottom: 28px;
    }
    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 18px;
      box-shadow: var(--shadow);
    }
    .card h2 {
      margin: 0 0 6px;
      font-size: 18px;
      letter-spacing: -0.01em;
    }
    .hint {
      color: var(--muted);
      font-size: 13px;
      margin-bottom: 12px;
    }
    .drop {
      border: 1px dashed var(--border);
      border-radius: 12px;
      padding: 18px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      background: var(--card-strong);
      cursor: pointer;
      transition: border-color 0.2s ease, background 0.2s ease;
    }
    .drop:hover {
      border-color: var(--accent);
      background: rgba(255,94,138,0.08);
    }
    .drop strong { display: block; }
    .drop input { display: none; }
    .status {
      font-size: 13px;
      color: var(--muted);
      margin-top: 10px;
      min-height: 18px;
    }
    .status .ok { color: var(--accent-2); font-weight: 700; }
    .status .err { color: var(--danger); font-weight: 700; }
    .table-wrap {
      margin-top: 12px;
      border: 1px solid var(--border);
      border-radius: 12px;
      overflow: auto;
      max-height: 340px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
      min-width: 500px;
    }
    th, td {
      padding: 8px 10px;
      border-bottom: 1px solid var(--border);
      text-align: left;
      color: var(--text);
    }
    th {
      position: sticky;
      top: 0;
      background: rgba(17,24,39,0.9);
      z-index: 1;
      font-weight: 700;
      letter-spacing: 0.01em;
    }
    tbody tr:nth-child(odd) { background: rgba(255,255,255,0.02); }
    tbody tr:hover { background: rgba(255,94,138,0.08); }
    .badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 10px;
      background: rgba(34,197,94,0.15);
      color: var(--accent-2);
      font-weight: 600;
      font-size: 12px;
    }
    .rowcount { color: var(--muted); font-size: 12px; margin-left: 6px; }
    @media (max-width: 720px) {
      header { flex-direction: column; align-items: flex-start; }
      .grid { grid-template-columns: 1fr; }
    }
    nav {
      display: flex;
      gap: 10px;
      margin-bottom: 18px;
      flex-wrap: wrap;
    }
    .nav-btn {
      padding: 10px 14px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: var(--card);
      color: var(--text);
      font-weight: 700;
      cursor: pointer;
      transition: all 0.2s ease;
      letter-spacing: 0.01em;
    }
    .nav-btn.danger {
      border-color: rgba(244,63,94,0.5);
      color: var(--danger);
      background: rgba(244,63,94,0.08);
    }
    .nav-btn.active {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(255,94,138,0.3), var(--shadow);
      color: var(--accent);
    }
    .hidden { display: none; }
    .toast {
      position: fixed;
      right: 18px;
      bottom: 18px;
      min-width: 260px;
      max-width: 360px;
      padding: 14px 16px;
      border-radius: 12px;
      background: #0b1220;
      border: 1px solid var(--border);
      color: var(--text);
      box-shadow: var(--shadow);
      opacity: 0;
      transform: translateY(12px);
      transition: opacity 0.2s ease, transform 0.2s ease;
      z-index: 999;
    }
    .toast.show {
      opacity: 1;
      transform: translateY(0);
    }
    .toast.success { border-color: rgba(34,197,94,0.5); }
    .toast.error { border-color: rgba(244,63,94,0.5); }
    .dash-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 12px;
      margin-top: 12px;
    }
    .dash-card {
      padding: 12px;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: var(--card-strong);
      box-shadow: 0 10px 25px rgba(0,0,0,0.35);
    }
    .dash-label { color: var(--muted); font-size: 12px; }
    .dash-value { font-size: 18px; font-weight: 700; }
    .graph-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 14px;
      margin-top: 16px;
    }
    .graph-card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 12px;
      box-shadow: 0 12px 28px rgba(0,0,0,0.4);
    }
    .graph-title {
      margin: 0 0 8px;
      font-size: 14px;
      color: var(--muted);
      display: flex;
      align-items: center;
      gap: 8px;
    }
    canvas { width: 100%; height: 160px; }
    .filters {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin: 10px 0;
      align-items: center;
    }
    .filters label {
      color: var(--muted);
      font-size: 12px;
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 6px;
      margin: 0;
    }
    .filters input {
      background: var(--card);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 8px 10px;
      border-radius: 8px;
    }
    .filters .divider {
      align-self: center;
      width: 1px;
      height: 28px;
      background: var(--border);
      margin: 0 6px;
    }
    .quick-filters {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }
    .quick-btn {
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: var(--card);
      color: var(--text);
      font-size: 12px;
      cursor: pointer;
      transition: border-color 0.2s ease, background 0.2s ease;
    }
    .quick-btn:hover {
      border-color: var(--accent);
      background: rgba(255,94,138,0.1);
    }
    .quick-btn.active {
      border-color: var(--accent);
      background: rgba(255,94,138,0.2);
      color: var(--text);
    }
    .tooltip {
      position: fixed;
      pointer-events: none;
      background: #0b1220;
      border: 1px solid var(--border);
      color: var(--text);
      padding: 8px 10px;
      border-radius: 8px;
      font-size: 12px;
      box-shadow: var(--shadow);
      opacity: 0;
      transition: opacity 0.1s ease;
      z-index: 1000;
    }
  </style>
</head>
<body>
  <div class="shell">
    <header>
      <div class="title">
        <span class="heart">❤</span>
        <span>myHealth</span>
      </div>
    </header>

    <nav>
      <button class="nav-btn active" data-target="dashboard">Dashboard</button>
      <button class="nav-btn" data-target="newlog">New Entry</button>
      <button class="nav-btn" data-target="logs">Logs</button>
      <button class="nav-btn" data-target="import">Import / Export</button>
    </nav>

    <section id="dashboard-section">
      <div class="card" id="dashboard-stats">
        <h2>Dashboard</h2>
        <div class="hint">Overview of diary and pain logs.</div>
        <div class="filters">
          <label>From
            <input type="date" id="filter-from" />
          </label>
          <label>To
            <input type="date" id="filter-to" />
          </label>
          <div class="divider"></div>
          <div class="quick-filters">
            <button class="quick-btn" data-range="7">1 week</button>
            <button class="quick-btn" data-range="30">1 month</button>
            <button class="quick-btn" data-range="90">3 months</button>
            <button class="quick-btn" data-range="180">6 months</button>
            <button class="quick-btn" data-range="365">1 year</button>
            <button class="quick-btn" data-range="1095">3 years</button>
            <button class="quick-btn" data-range="all">Since start</button>
          </div>
        </div>
        <div class="dash-grid" id="dash-cards"></div>
      </div>
      <div class="graph-grid" id="dash-graphs"></div>
    </section>

    <section id="newlog-section" class="hidden">
      <div class="card">
        <h2>New Entry</h2>
        <div class="hint">Coming soon.</div>
      </div>
    </section>

    <section id="logs-section" class="hidden">
      <div class="grid">
        <div class="card">
          <h2>Diary log</h2>
          <div class="hint">Showing the latest diary data saved in the local JSON store.</div>
          <div class="status" id="diary-status-log"></div>
          <div class="table-wrap" id="diary-table"></div>
        </div>
        <div class="card">
          <h2>Pain log</h2>
          <div class="hint">Showing the latest pain data saved in the local JSON store.</div>
          <div class="status" id="pain-status-log"></div>
          <div class="table-wrap" id="pain-table"></div>
        </div>
      </div>
    </section>

    <section id="import-section" class="hidden">
      <div class="grid">
        <div class="card">
          <h2></h2>
          <label class="drop">
            <div>
              <strong>Select or drop Diary CSV</strong>
            </div>
            <input type="file" accept=".csv,text/csv" data-kind="diary" />
            <span class="badge">Import</span>
          </label>
          <div class="status" id="diary-status-import"></div>
          <div style="margin-top:10px; display:flex; gap:10px; flex-wrap:wrap;">
            <button class="nav-btn" data-export="diary" data-type="csv">Export Diary CSV</button>
            <button class="nav-btn" data-export="diary" data-type="json">Export Diary JSON</button>
            <button class="nav-btn danger" data-purge="diary">Purge Diary Data</button>
          </div>
        </div>
        <div class="card">
          <h2></h2>
          <label class="drop">
            <div>
              <strong>Select or drop Pain CSV</strong>
            </div>
            <input type="file" accept=".csv,text/csv" data-kind="pain" />
            <span class="badge">Import</span>
          </label>
          <div class="status" id="pain-status-import"></div>
          <div style="margin-top:10px; display:flex; gap:10px; flex-wrap:wrap;">
            <button class="nav-btn" data-export="pain" data-type="csv">Export Pain CSV</button>
            <button class="nav-btn" data-export="pain" data-type="json">Export Pain JSON</button>
            <button class="nav-btn danger" data-purge="pain">Purge Pain Data</button>
          </div>
        </div>
      </div>
    </section>
  </div>

  <script>
    const datasets = {
      diary: {
        file: "diary.json",
        logsTable: document.getElementById("diary-table"),
        statusLog: document.getElementById("diary-status-log"),
        statusImport: document.getElementById("diary-status-import"),
      },
      pain: {
        file: "pain.json",
        logsTable: document.getElementById("pain-table"),
        statusLog: document.getElementById("pain-status-log"),
        statusImport: document.getElementById("pain-status-import"),
      },
    };
    const dataStore = { diary: null, pain: null };
    const REQUIRED = {
      diary: ["file name", "created time", "mood level", "depression", "anxiety"],
      pain: [
        "file name",
        "created time",
        "pain level",
        "fatigue level",
        "mood level",
        "symptoms",
        "area",
        "activities",
        "good sleep",
        "healthy food",
        "coffee",
        ">6h day byte",
        ">1h masturbation",
        "<1h masturbation",
        "cum",
        "medicines",
        "note",
      ],
    };
    const ALIASES = {
      diary: {},
      pain: {
        "pain level": ["pain level", "pain"],
        "fatigue level": ["fatigue level", "fatigue"],
        "mood level": ["mood level", "mood"],
        "good sleep": ["good sleep", "sleep"],
      },
    };

    async function fetchExisting(kind) {
      const cfg = datasets[kind];
      try {
        const res = await fetch(`/api/files/${cfg.file}`);
        if (!res.ok) return;
        const data = await res.json();
        if (data && data.rows && data.headers) {
          dataStore[kind] = data;
          renderTable(kind, data.headers, data.rows);
          setStatus(kind, `Loaded ${data.rows.length} rows from ${cfg.file}`, true, "logs");
          renderDashboard();
        }
      } catch (err) {
        console.warn("Load error", err);
      }
    }

    function setStatus(kind, message, ok = false, target = "logs") {
      const el = target === "import" ? datasets[kind].statusImport : datasets[kind].statusLog;
      if (!el) return;
      el.innerHTML = message ? `<span class="${ok ? "ok" : "err"}">${ok ? "OK" : "Error"}:</span> ${message}` : "";
    }

    function showPopup(message, ok = true) {
      let toast = document.getElementById("toast");
      if (!toast) {
        toast = document.createElement("div");
        toast.id = "toast";
        toast.className = "toast";
        document.body.appendChild(toast);
      }
      toast.className = `toast ${ok ? "success" : "error"}`;
      toast.textContent = message;
      requestAnimationFrame(() => toast.classList.add("show"));
      setTimeout(() => toast.classList.remove("show"), 2800);
    }

    function renderTable(kind, headers, rows) {
      const cfg = datasets[kind];
      if (!headers || !rows) {
        cfg.logsTable.innerHTML = "";
        return;
      }
      const thead = `<thead><tr>${headers.map(h => `<th>${escapeHtml(h)}</th>`).join("")}</tr></thead>`;
      const tbody = `<tbody>${rows.map(r => `<tr>${headers.map(h => `<td>${escapeHtml(r[h] ?? "")}</td>`).join("")}</tr>`).join("")}</tbody>`;
      cfg.logsTable.innerHTML = `<table>${thead}${tbody}</table><div class="rowcount">${rows.length} rows</div>`;
    }

    function escapeHtml(str) {
      return String(str)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }

    function parseCSV(text) {
      const rows = [];
      let current = [];
      let value = "";
      let inQuotes = false;
      for (let i = 0; i < text.length; i++) {
        const c = text[i];
        if (inQuotes) {
          if (c === '"') {
            if (text[i + 1] === '"') {
              value += '"';
              i++;
            } else {
              inQuotes = false;
            }
          } else {
            value += c;
          }
        } else {
          if (c === '"') {
            inQuotes = true;
          } else if (c === ",") {
            current.push(value);
            value = "";
          } else if (c === "\n") {
            current.push(value);
            rows.push(current);
            current = [];
            value = "";
          } else if (c === "\r") {
            continue;
          } else {
            value += c;
          }
        }
      }
      if (value !== "" || current.length) {
        current.push(value);
        rows.push(current);
      }
      const headers = rows.shift() || [];
      const objects = rows.filter(r => r.length && r.some(cell => cell.trim() !== "")).map(r => {
        const obj = {};
        headers.forEach((h, idx) => obj[h.trim()] = r[idx] ?? "");
        return obj;
      });
      return { headers, rows: objects };
    }

    async function handleFile(kind, file) {
      const cfg = datasets[kind];
      if (!file) return;
      try {
        const text = await file.text();
        const parsed = parseCSV(text);
        if (!parsed.headers.length) throw new Error("No headers detected");
        if (!hasCreatedTime(parsed.headers)) throw new Error('Missing "created time" column');
        const validateMsg = validateHeaders(kind, parsed.headers);
        if (validateMsg) throw new Error(validateMsg);
        const result = await persist(kind, parsed, file.name);
        setStatus(kind, `Imported ${result.added} new, ${result.skipped} existing (source: ${file.name})`, true, "import");
        showPopup(`Imported ${result.added} new, ${result.skipped} already present`, true);
      } catch (err) {
        setStatus(kind, err.message || "Failed to parse", false, "import");
        showPopup(err.message || "Import failed", false);
      }
    }

    function normalizeHeaderName(h) {
      return h
        .replace(/^\uFEFF/, "")
        .toLowerCase()
        .replace(/\u00a0/g, " ") // nbsp to space
        .replace(/[-_–—]+/g, " ")
        .replace(/\s+/g, " ")
        .trim();
    }

    function hasCreatedTime(headers) {
      return headers.some(h => normalizeHeaderName(h) === "created time");
    }

    function validateHeaders(kind, headers) {
      const expected = REQUIRED[kind];
      if (!expected) return "";
      const normalized = headers.map(normalizeHeaderName);
      const set = new Set(normalized);
      const aliasMap = ALIASES[kind] || {};
      const missing = [];
      expected.forEach(req => {
        const aliases = aliasMap[req] || [req];
        const found = aliases.some(a => set.has(normalizeHeaderName(a)));
        if (!found) missing.push(req);
      });
      return missing.length ? `Missing columns for ${kind}: ${missing.join(", ")}` : "";
    }

    function findHeader(headers, target) {
      const wanted = normalizeHeaderName(target);
      for (const h of headers) {
        if (normalizeHeaderName(h) === wanted) return h;
      }
      return null;
    }

    async function persist(kind, parsed, sourceName) {
      const cfg = datasets[kind];
      try {
        const createdKey = findHeader(parsed.headers, "created time");
        if (!createdKey) throw new Error('Missing "created time" column');

        const existing = dataStore[kind]?.rows || [];
        const existingHeaders = dataStore[kind]?.headers || parsed.headers;
        const existingCreatedKey = findHeader(existingHeaders, "created time") || createdKey;
        const seen = new Set(existing.map(r => (r[existingCreatedKey] || "").trim()));
        let added = 0;
        let skipped = 0;
        const mergedRows = [...existing];

        parsed.rows.forEach(r => {
          const created = (r[createdKey] || "").trim();
          if (!created) return;
          if (seen.has(created)) {
            skipped += 1;
          } else {
            seen.add(created);
            mergedRows.push(r);
            added += 1;
          }
        });

        const mergedHeaders = dataStore[kind]?.headers?.length ? dataStore[kind].headers : parsed.headers;
        const payload = {
          source: sourceName,
          imported_at: new Date().toISOString(),
          headers: mergedHeaders,
          rows: mergedRows,
        };
        const res = await fetch(`/api/files/${cfg.file}`, {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });
        if (!res.ok) {
          throw new Error(`Server returned ${res.status}`);
        }
        dataStore[kind] = payload;
        renderTable(kind, parsed.headers, mergedRows);
        setStatus(kind, `Saved to ${cfg.file} (${mergedRows.length} total rows)`, true, "import");
        setStatus(kind, `Updated ${mergedRows.length} rows from ${sourceName}`, true, "logs");
        renderDashboard();
        return { added, skipped };
      } catch (err) {
        console.error(err);
        setStatus(kind, err.message || "Failed to save", false, "import");
        throw err;
      }
    }

    function wireDropZones() {
      document.querySelectorAll('input[type="file"]').forEach(input => {
        input.addEventListener("change", (e) => {
          const kind = e.target.dataset.kind;
          const file = e.target.files?.[0];
          handleFile(kind, file);
        });
        const label = input.closest(".drop");
        label.addEventListener("dragover", (e) => { e.preventDefault(); label.classList.add("hover"); });
        label.addEventListener("dragleave", () => label.classList.remove("hover"));
        label.addEventListener("drop", (e) => {
          e.preventDefault();
          label.classList.remove("hover");
          const file = e.dataTransfer.files?.[0];
          handleFile(input.dataset.kind, file);
        });
      });
    }

    function wireNav() {
      const buttons = document.querySelectorAll(".nav-btn[data-target]");
      const sections = {
        dashboard: document.getElementById("dashboard-section"),
        newlog: document.getElementById("newlog-section"),
        logs: document.getElementById("logs-section"),
        import: document.getElementById("import-section"),
      };
      buttons.forEach(btn => {
        btn.addEventListener("click", () => {
          const target = btn.dataset.target;
          buttons.forEach(b => b.classList.toggle("active", b === btn));
          Object.entries(sections).forEach(([key, el]) => {
            el.classList.toggle("hidden", key !== target);
          });
        });
      });
    }

    function renderDashboard() {
      const container = document.getElementById("dash-cards");
      const graphs = document.getElementById("dash-graphs");
      if (!container || !graphs) return;
      const diary = applyDateFilter(dataStore.diary);
      const pain = applyDateFilter(dataStore.pain);

      const diaryCount = diary?.rows?.length || 0;
      const painCount = pain?.rows?.length || 0;
      const diaryMoodAvg = avgField(diary, "mood level");
      const diaryDepAvg = avgField(diary, "depression");
      const diaryAnxAvg = avgField(diary, "anxiety");
      const painLevelAvg = avgField(pain, "pain level");
      const fatigueAvg = avgField(pain, "fatigue level");

      const cards = [
        { label: "Diary entries", value: diaryCount },
        { label: "Pain entries", value: painCount },
        { label: "Mood avg", value: diaryMoodAvg ?? "–" },
        { label: "Depression avg", value: diaryDepAvg ?? "–" },
        { label: "Anxiety avg", value: diaryAnxAvg ?? "–" },
        { label: "Pain avg", value: painLevelAvg ?? "–" },
        { label: "Fatigue avg", value: fatigueAvg ?? "–" },
      ];

      container.innerHTML = cards
        .map(
          (c) => `
            <div class="dash-card">
              <div class="dash-label">${escapeHtml(c.label)}</div>
              <div class="dash-value">${escapeHtml(c.value)}</div>
            </div>
          `
        )
        .join("");

      const graphDefs = [
        { id: "graph-diary-mood", title: "Diary: Mood over time", yLabel: "Mood level", data: timeSeries(diary, "mood level") },
        { id: "graph-pain-level", title: "Pain: Pain level over time", yLabel: "Pain level", data: timeSeries(pain, "pain level") },
        { id: "graph-fatigue", title: "Pain: Fatigue level over time", yLabel: "Fatigue level", data: timeSeries(pain, "fatigue level") },
      ];

      graphs.innerHTML = graphDefs
        .map(
          (g) => `
            <div class="graph-card">
              <div class="graph-title">${escapeHtml(g.title)}</div>
              <canvas id="${g.id}"></canvas>
            </div>
          `
        )
        .join("");

      graphDefs.forEach((g, idx) => {
        const canvas = document.getElementById(g.id);
        drawLineChart(canvas, g.data, idx, { yLabel: g.yLabel });
      });
    }

    function avgField(store, field) {
      if (!store?.rows?.length) return null;
      const key = findHeader(store.headers, field) || field;
      let sum = 0;
      let count = 0;
      store.rows.forEach((row) => {
        const val = parseFloat(row[key]);
        if (!Number.isNaN(val)) {
          sum += val;
          count += 1;
        }
      });
      if (!count) return null;
      return (sum / count).toFixed(2);
    }

    function timeSeries(store, field) {
      if (!store?.rows?.length) return [];
      const key = findHeader(store.headers, field) || field;
      const createdKey = findHeader(store.headers, "created time") || "created time";
      return store.rows
        .map((row) => {
          const d = new Date(row[createdKey]);
          const v = parseFloat(row[key]);
          return { t: d, v };
        })
        .filter((p) => p.t.toString() !== "Invalid Date" && !Number.isNaN(p.v))
        .sort((a, b) => a.t - b.t);
    }

    const graphMeta = {};

    function drawLineChart(canvas, data, idx, opts = {}) {
      if (!canvas || !canvas.getContext) return;
      const ctx = canvas.getContext("2d");
      const width = (canvas.width = canvas.offsetWidth || 320);
      const height = (canvas.height = canvas.offsetHeight || 180);
      ctx.clearRect(0, 0, width, height);
      ctx.strokeStyle = [ "#ff5e8a", "#ff8fb1", "#ffb3c9" ][idx % 3];
      ctx.lineWidth = 2;
      ctx.fillStyle = "rgba(255,255,255,0.04)";
      ctx.fillRect(0, 0, width, height);
      if (!data.length) {
        ctx.fillStyle = "rgba(226,232,240,0.7)";
        ctx.fillText("No data yet", 12, 20);
        return;
      }
      const yBounds = getYBounds(opts.yLabel, data);
      const minY = yBounds.min;
      const maxY = yBounds.max;
      const minX = data[0].t.getTime();
      const maxX = data[data.length - 1].t.getTime();
      const pad = 28;
      ctx.beginPath();
      const points = [];
      data.forEach((pt, i) => {
        const x = scale(pt.t.getTime(), minX, maxX || minX + 1, pad, width - pad);
        const y = scale(pt.v, maxY === minY ? minY - 1 : minY, maxY === minY ? minY + 1 : maxY, height - pad, pad);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
        points.push({ x, y, ...pt });
      });
      ctx.stroke();
      ctx.fillStyle = ctx.strokeStyle;
      data.forEach((pt) => {
        const x = scale(pt.t.getTime(), minX, maxX || minX + 1, pad, width - pad);
        const y = scale(pt.v, maxY === minY ? minY - 1 : minY, maxY === minY ? minY + 1 : maxY, height - pad, pad);
        ctx.beginPath();
        ctx.arc(x, y, 3, 0, Math.PI * 2);
        ctx.fill();
      });

      // axis labels
      ctx.fillStyle = "rgba(226,232,240,0.7)";
      ctx.font = "11px Manrope, sans-serif";
      ctx.textAlign = "center";
      ctx.fillText("Date", width / 2, height - 6);
      ctx.save();
      ctx.translate(10, height / 2);
      ctx.rotate(-Math.PI / 2);
      ctx.textAlign = "center";
      ctx.fillText(opts.yLabel || "Value", 0, 0);
      ctx.restore();

      // axis ticks
      drawAxes(ctx, width, height, pad, minX, maxX, minY, maxY, data);

      graphMeta[canvas.id] = { points, yLabel: opts.yLabel || "Value" };
      canvas.onmousemove = (e) => handleHover(canvas, e);
      canvas.onmouseleave = () => hideTooltip();
    }

    function scale(val, min, max, outMin, outMax) {
      if (max === min) return (outMin + outMax) / 2;
      return outMin + ((val - min) / (max - min)) * (outMax - outMin);
    }

    function getYBounds(label, data) {
      const rawMin = Math.min(...data.map(d => d.v));
      const rawMax = Math.max(...data.map(d => d.v));
      const normLabel = (label || "").toLowerCase();
      const preset = ["pain", "fatigue", "mood", "depression", "anxiety"].some(k => normLabel.includes(k));
      let min = preset ? 0 : rawMin;
      let max = preset ? 10 : rawMax;
      if (!preset) {
        const pad = Math.max(1, (rawMax - rawMin) * 0.1);
        min = rawMin - pad;
        max = rawMax + pad;
      }
      if (min === max) {
        min -= 1;
        max += 1;
      }
      return { min, max };
    }

    function drawAxes(ctx, width, height, pad, minX, maxX, minY, maxY, data) {
      ctx.strokeStyle = "rgba(226,232,240,0.2)";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(pad, pad);
      ctx.lineTo(pad, height - pad);
      ctx.lineTo(width - pad, height - pad);
      ctx.stroke();

      ctx.fillStyle = "rgba(226,232,240,0.7)";
      ctx.font = "10px Manrope, sans-serif";
      ctx.textAlign = "right";
      const yTicks = 5;
      for (let i = 0; i <= yTicks; i++) {
        const v = minY + ((maxY - minY) * i) / yTicks;
        const y = scale(v, minY, maxY, height - pad, pad);
        ctx.fillText(v.toFixed(0), pad - 6, y + 3);
        ctx.strokeStyle = "rgba(226,232,240,0.08)";
        ctx.beginPath();
        ctx.moveTo(pad + 2, y);
        ctx.lineTo(width - pad, y);
        ctx.stroke();
      }

      const xLabels = pickXLabels(data);
      ctx.textAlign = "center";
      xLabels.forEach((lbl) => {
        const x = scale(lbl.time, minX, maxX || minX + 1, pad, width - pad);
        ctx.fillText(lbl.text, x, height - pad + 12);
        ctx.strokeStyle = "rgba(226,232,240,0.08)";
        ctx.beginPath();
        ctx.moveTo(x, height - pad);
        ctx.lineTo(x, pad);
        ctx.stroke();
      });
    }

    function pickXLabels(data) {
      const labels = [];
      const total = data.length;
      const step = Math.max(1, Math.floor(total / 4));
      for (let i = 0; i < total; i += step) {
        const d = data[i];
        const text = d.t instanceof Date ? d.t.toISOString().slice(5, 10) : String(d.t);
        labels.push({ time: d.t.getTime(), text });
      }
      if (labels.length && labels[labels.length - 1].time !== data[total - 1].t.getTime()) {
        const last = data[total - 1];
        labels.push({ time: last.t.getTime(), text: last.t.toISOString().slice(5, 10) });
      }
      return labels;
    }

    function handleHover(canvas, evt) {
      const meta = graphMeta[canvas.id];
      if (!meta || !meta.points?.length) return hideTooltip();
      const rect = canvas.getBoundingClientRect();
      const x = evt.clientX - rect.left;
      const y = evt.clientY - rect.top;
      let closest = null;
      let minDist = Infinity;
      meta.points.forEach((p) => {
        const dx = p.x - x;
        const dy = p.y - y;
        const dist = Math.hypot(dx, dy);
        if (dist < minDist) {
          minDist = dist;
          closest = p;
        }
      });
      if (!closest || minDist > 12) return hideTooltip();
      const tooltip = getTooltip();
      const dateStr = closest.t instanceof Date ? closest.t.toISOString().slice(0, 10) : String(closest.t);
      tooltip.innerHTML = `<strong>${meta.yLabel}:</strong> ${closest.v}<br/><span style="color:${'var(--muted)'}">${dateStr}</span>`;
      tooltip.style.left = `${evt.clientX + 12}px`;
      tooltip.style.top = `${evt.clientY + 12}px`;
      tooltip.style.opacity = "1";
    }

    function hideTooltip() {
      const t = document.getElementById("tooltip");
      if (t) t.style.opacity = "0";
    }

    function getTooltip() {
      let t = document.getElementById("tooltip");
      if (!t) {
        t = document.createElement("div");
        t.id = "tooltip";
        t.className = "tooltip";
        document.body.appendChild(t);
      }
      return t;
    }

    function setQuickActive(btn) {
      document.querySelectorAll(".quick-btn").forEach(b => b.classList.remove("active"));
      btn.classList.add("active");
    }

    function clearQuickActive() {
      document.querySelectorAll(".quick-btn").forEach(b => b.classList.remove("active"));
    }

    function toCSV(headers, rows) {
      const esc = (val) => {
        const s = String(val ?? "");
        if (s.includes(",") || s.includes('"') || s.includes("\n")) {
          return `"${s.replace(/"/g, '""')}"`;
        }
        return s;
      };
      const head = headers.map(esc).join(",");
      const body = rows.map(r => headers.map(h => esc(r[h])).join(",")).join("\n");
      return `${head}\n${body}`;
    }

    function wireExport() {
      document.querySelectorAll("[data-export]").forEach(btn => {
        btn.addEventListener("click", () => {
          const kind = btn.dataset.export;
          const type = btn.dataset.type;
          const data = dataStore[kind];
          try {
            if (!data || !data.headers || !data.rows) {
              throw new Error("No data loaded yet. Import first.");
            }
            let blob;
            let filename;
            if (type === "csv") {
              blob = new Blob([toCSV(data.headers, data.rows)], { type: "text/csv;charset=utf-8" });
              filename = `${kind}.csv`;
            } else {
              blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
              filename = `${kind}.json`;
            }
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
            showPopup(`Exported ${kind} as ${filename}`, true);
          } catch (err) {
            showPopup(err.message || "Export failed", false);
          }
        });
      });
    }

    function wirePurge() {
      document.querySelectorAll("[data-purge]").forEach(btn => {
        btn.addEventListener("click", async () => {
          const kind = btn.dataset.purge;
          try {
            const confirmFirst = confirm(`Are you sure you want to purge all ${kind} data?`);
            if (!confirmFirst) return;
            const confirmSecond = confirm("This will remove all rows. Confirm purge?");
            if (!confirmSecond) return;
            const payload = {
              source: "purge",
              imported_at: new Date().toISOString(),
              headers: dataStore[kind]?.headers || REQUIRED[kind] || [],
              rows: [],
            };
            const res = await fetch(`/api/files/${datasets[kind].file}`, {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(payload),
            });
            if (!res.ok) throw new Error(`Server returned ${res.status}`);
            dataStore[kind] = payload;
            renderTable(kind, payload.headers, payload.rows);
            setStatus(kind, "Purged all rows", true, "import");
            setStatus(kind, "Purged all rows", true, "logs");
            showPopup(`Purged ${kind} data`, true);
            renderDashboard();
          } catch (err) {
            showPopup(err.message || "Purge failed", false);
            setStatus(kind, err.message || "Purge failed", false, "import");
          }
        });
      });
    }

    function applyDateFilter(store) {
      if (!store?.rows?.length) return store;
      const fromInput = document.getElementById("filter-from");
      const toInput = document.getElementById("filter-to");
      const fromVal = fromInput?.value ? new Date(fromInput.value) : null;
      const toVal = toInput?.value ? new Date(toInput.value) : null;
      if ((!fromVal || isNaN(fromVal)) && (!toVal || isNaN(toVal))) return store;
      const createdKey = findHeader(store.headers, "created time") || "created time";
      const filteredRows = store.rows.filter((row) => {
        const d = new Date(row[createdKey]);
        if (d.toString() === "Invalid Date") return false;
        if (fromVal && d < fromVal) return false;
        if (toVal && d > toVal) return false;
        return true;
      });
      return { ...store, rows: filteredRows };
    }

    wireDropZones();
    wireNav();
    wireExport();
    wirePurge();
    ["filter-from", "filter-to"].forEach((id) => {
      const el = document.getElementById(id);
      if (el) {
        el.addEventListener("change", () => {
          clearQuickActive();
          renderDashboard();
        });
      }
    });
    document.querySelectorAll(".quick-btn").forEach((btn) => {
      btn.addEventListener("click", () => {
        const range = btn.dataset.range;
        const fromInput = document.getElementById("filter-from");
        const toInput = document.getElementById("filter-to");
        const today = new Date();
        const toStr = today.toISOString().slice(0, 10);
        if (range === "all") {
          if (fromInput) fromInput.value = "";
          if (toInput) toInput.value = "";
        } else {
          const days = parseInt(range, 10);
          const from = new Date(today.getTime() - days * 24 * 60 * 60 * 1000);
          const fromStr = from.toISOString().slice(0, 10);
          if (fromInput) fromInput.value = fromStr;
          if (toInput) toInput.value = toStr;
        }
        setQuickActive(btn);
        renderDashboard();
      });
    });
    fetchExisting("diary");
    fetchExisting("pain");
    renderDashboard();
  </script>
</body>
</html>
