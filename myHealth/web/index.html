<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>myHealth CSV Importer</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;600;700&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <link rel="stylesheet" href="/myhealth/style.css">
</head>

<body>
  <div class="shell">
    <header>
      <div class="title">
        <span class="heart">‚ù§</span>
        <span>myHealth</span>
      </div>
    </header>

    <div class="card auth-card">
      <div class="auth-row">
        <input type="email" id="auth-email" placeholder="Email" autocomplete="username" />
        <input type="password" id="auth-pass" placeholder="Password" autocomplete="current-password" />
        <button class="btn-primary" id="auth-login" type="button">Log in</button>
      </div>
      <div class="status" id="auth-status"></div>
      <pre class="debug-log hidden" id="auth-debug"></pre>
    </div>

    <div id="app-main" class="hidden">
      <div class="top-nav">
        <nav>
          <button class="nav-btn active" data-target="dashboard">
            <svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" aria-hidden="true">
              <path d="M4 13h6V4H4v9zm10 7h6V4h-6v16z" />
            </svg>
            Dashboard
          </button>
          <button class="nav-btn" data-target="newlog">
            <svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" aria-hidden="true">
              <path d="M6 5h12v14H6z" />
              <path d="M9 3v4m6-4v4M8 10h8m-8 4h6" />
            </svg>
            Logs and new entries
          </button>
          <button class="nav-btn" data-target="import">
            <svg class="icon" width="14" height="14" viewBox="0 0 24 24" fill="none" aria-hidden="true">
              <path d="M12 16V4m0 0l-3 3m3-3l3 3" />
              <path d="M6 13v5h12v-5" />
            </svg>
            Import / Export
          </button>
        </nav>
        <div class="top-actions">
          <a class="nav-btn hub-link hidden" id="go-hub" href="/" aria-label="Back to hub">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" aria-hidden="true">
              <path d="M15 5l-7 7 7 7" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
            </svg>
            <span>Back to hub</span>
          </a>
          <button class="nav-btn danger logout-btn hidden" id="auth-logout" type="button">Log out</button>
        </div>
      </div>

      <section id="dashboard-section">
        <div class="card" id="dashboard-stats">
          <h2>Dashboard</h2>
          <div class="hint">Overview of diary and pain logs.</div>
          <div class="filters">
            <label>From
              <input type="date" id="filter-from" />
            </label>
            <label>To
              <input type="date" id="filter-to" />
            </label>
            <div class="divider"></div>
            <div class="quick-filters">
              <button class="quick-btn" data-range="7">1 week</button>
              <button class="quick-btn" data-range="30">1 month</button>
              <button class="quick-btn" data-range="90">3 months</button>
              <button class="quick-btn" data-range="180">6 months</button>
              <button class="quick-btn" data-range="365">1 year</button>
              <button class="quick-btn" data-range="1095">3 years</button>
              <button class="quick-btn" data-range="all">Since start</button>
            </div>
          </div>
          <div class="dash-grid" id="dash-cards"></div>
        </div>
        <div class="graph-grid" id="dash-graphs"></div>
      </section>

      <section id="newlog-section" class="hidden">
        <div class="card">
          <h2>New Entry</h2>
          <div class="hint">Capture a quick log without waiting for a CSV import.</div>
          <div class="entry-tabs" role="tablist" aria-label="New entry categories">
            <button class="nav-btn entry-btn active" data-entry="pain" type="button">Physical pain</button>
            <button class="nav-btn entry-btn" id="autotherapy-tab" data-entry="autotherapy" type="button">Autotherapy
              ‚óÄ</button>
          </div>

          <div class="entry-panel" data-entry-panel="pain">
            <form id="pain-form">
              <div class="form-grid">
                <div class="form-group">
                  <label for="pain-date">Entry Date/Time</label>
                  <input id="pain-date" name="pain-date" type="datetime-local" />
                  <small>Stored as separate date + time columns; defaults to now if left empty.</small>
                </div>
                <div class="form-group">
                  <label for="pain-level">Pain Level (1-9)</label>
                  <input id="pain-level" name="pain-level" type="number" min="1" max="9" step="1"
                    placeholder="e.g. 6" />
                </div>
                <div class="form-group">
                  <label for="fatigue-level">Fatigue Level (1-9)</label>
                  <input id="fatigue-level" name="fatigue-level" type="number" min="1" max="9" step="1"
                    placeholder="e.g. 4" />
                </div>
                <div class="form-group">
                  <label>Area <button type="button" class="chip-edit" data-edit="area">Edit</button></label>
                  <div id="area-options" class="chip-row" data-field="area"></div>
                  <div id="area-editor" class="chip-editor hidden" data-field="area"></div>
                </div>
                <div class="form-group">
                  <label>Symptoms <button type="button" class="chip-edit" data-edit="symptoms">Edit</button></label>
                  <div id="symptoms-options" class="chip-row" data-field="symptoms"></div>
                  <div id="symptoms-editor" class="chip-editor hidden" data-field="symptoms"></div>
                </div>
                <div class="form-group">
                  <label>Activities <button type="button" class="chip-edit" data-edit="activities">Edit</button></label>
                  <div id="activities-options" class="chip-row" data-field="activities"></div>
                  <div id="activities-editor" class="chip-editor hidden" data-field="activities"></div>
                </div>
                <div class="form-group">
                  <label>Medicines <button type="button" class="chip-edit" data-edit="medicines">Edit</button></label>
                  <div id="medicines-options" class="chip-row" data-field="medicines" data-preselect="all"></div>
                  <div id="medicines-editor" class="chip-editor hidden" data-field="medicines"></div>
                </div>
                <div class="form-group">
                  <label for="pain-note">Notes</label>
                  <textarea id="pain-note" name="pain-note" placeholder="Anything else worth tracking?"></textarea>
                </div>
                <div class="form-group">
                  <label>Habits <button type="button" class="chip-edit" data-edit="habits">Edit</button></label>
                  <div id="habits-options" class="chip-row" data-field="habits"></div>
                  <div id="habits-editor" class="chip-editor hidden" data-field="habits"></div>
                </div>
                <div class="form-group">
                  <label for="coffee-count">Coffee (cups)</label>
                  <input id="coffee-count" name="coffee-count" type="number" min="0" max="9" step="1"
                    placeholder="e.g. 1" />
                </div>
                <div class="form-group">
                  <label>Other <button type="button" class="chip-edit" data-edit="other">Edit</button></label>
                  <div id="other-options" class="chip-row" data-field="other"></div>
                  <div id="other-editor" class="chip-editor hidden" data-field="other"></div>
                </div>
              </div>
              <div class="form-actions">
                <button class="btn-primary btn-plain" id="pain-submit-btn" type="submit">Save new entry</button>
                <button class="btn-muted hidden" id="pain-cancel-btn" type="button">Cancel edit</button>
                <div id="pain-form-status" class="status"></div>
              </div>
            </form>
            <div class="form-divider"></div>
            <div class="card">
              <div class="log-header">
                <h2>Pain log <span id="pain-count" style="color:var(--muted); font-size:14px; margin-left:8px;"></span>
                </h2>
              </div>
              <div class="list-wrap" id="pain-table"></div>
            </div>
          </div>

          <div class="entry-panel hidden" data-entry-panel="autotherapy">
            <div id="autotherapy-stack">
              <div class="entry-tabs autotherapy-subnav" role="tablist" aria-label="Autotherapy entries">
                <button class="nav-btn entry-btn secondary" data-autotherapy="journal" type="button">Journal</button>
                <button class="nav-btn entry-btn secondary" data-autotherapy="cbt" type="button">CBT thought
                  response</button>
                <button class="nav-btn entry-btn secondary" data-autotherapy="dbt" type="button">DBT distress
                  tolerance</button>
              </div>
              <div class="entry-panel hidden" data-autotherapy-panel="journal">
                <form id="journal-form">
                  <div class="form-grid">
                    <div class="form-group">
                      <label for="journal-date">Entry date/time</label>
                      <input id="journal-date" name="journal-date" type="datetime-local" />
                      <small>Stored as separate date + time columns; defaults to now if left empty.</small>
                    </div>
                    <div class="form-group">
                      <label for="journal-mood">Mood level (1-9)</label>
                      <input id="journal-mood" name="journal-mood" type="number" min="1" max="9" step="1"
                        placeholder="e.g. 6" />
                    </div>
                    <div class="form-group">
                      <label for="journal-depression">Depression (1-9)</label>
                      <input id="journal-depression" name="journal-depression" type="number" min="1" max="9" step="1"
                        placeholder="e.g. 4" />
                    </div>
                    <div class="form-group">
                      <label for="journal-anxiety">Anxiety (1-9)</label>
                      <input id="journal-anxiety" name="journal-anxiety" type="number" min="1" max="9" step="1"
                        placeholder="e.g. 5" />
                    </div>
                    <div class="form-group" style="grid-column: 1 / -1;">
                      <label for="journal-description">description</label>
                      <textarea id="journal-description" name="journal-description"
                        placeholder="cosa hai fatto oggi?"></textarea>
                    </div>
                    <div class="form-group" style="grid-column: 1 / -1;">
                      <label for="journal-gratitude">gratitude</label>
                      <textarea id="journal-gratitude" name="journal-gratitude"
                        placeholder="per cosa sei grato?"></textarea>
                    </div>
                    <div class="form-group" style="grid-column: 1 / -1;">
                      <label for="journal-reflection">reflection</label>
                      <textarea id="journal-reflection" name="journal-reflection"
                        placeholder="vuoi riflettere su qualcosa?"></textarea>
                    </div>
                  </div>
                  <div class="form-actions">
                    <button class="btn-primary btn-plain" id="journal-submit-btn" type="submit">Save journal
                      entry</button>
                    <button class="btn-muted hidden" id="journal-cancel-btn" type="button">Cancel edit</button>
                    <div id="journal-form-status" class="status"></div>
                  </div>
                </form>
                <div class="form-divider"></div>
                <div class="card">
                  <div class="log-header">
                    <h2>Journal log <span id="diary-count"
                        style="color:var(--muted); font-size:14px; margin-left:8px;"></span></h2>
                  </div>
                  <div class="list-wrap" id="diary-table"></div>
                </div>
              </div>
              <div class="entry-panel hidden" data-autotherapy-panel="cbt">
                <div class="hint">CBT thought response coming soon.</div>
              </div>
              <div class="entry-panel hidden" data-autotherapy-panel="dbt">
                <div class="hint">DBT distress tolerance coming soon.</div>
              </div>
            </div>
          </div>
        </div>
      </section>

      <section id="import-section" class="hidden">
        <div class="card">
          <h2>Import / backup</h2>
          <div class="hint">easily import or export your data</div>

          <div class="stacked-fields" style="gap: 15px;">
            <div class="field-group">
              <label><strong>Import from JSON</strong></label><br>
              <input type="file" id="import-backup-input" accept=".json" />
            </div>
            <div class="field-group">
              <button class="btn-primary btn-plain" id="export-backup-button">Export JSON</button>
            </div>

            <div class="section-divider"></div>

            <div class="field-group">
              <label><strong>Import from XLSX</strong> (sheets: <code>diary</code>, <code>pain</code>)</label><br>
              <input type="file" id="import-xlsx-input" accept=".xlsx,.xls" />
            </div>
            <div class="field-group">
              <button class="btn-primary btn-plain" id="export-xlsx-button">Export XLSX</button>
            </div>

            <div class="section-divider"></div>

            <div class="field-group">
              <button class="nav-btn danger" id="full-purge-button">üß® delete all data</button>
            </div>
          </div>
        </div>

        <div class="status" id="backup-status"></div>
        <pre class="error-box hidden" id="backup-error"></pre>

        <!-- hidden status nodes to satisfy existing refs -->
        <div class="status hidden" id="diary-status-import"></div>
        <div class="status hidden" id="pain-status-import"></div>
    </div>
    </section>
  </div>
  </div>

  <script>
    const datasets = {
      diary: {
        file: "diary.json",
        logsTable: document.getElementById("diary-table"),
        statusLog: document.getElementById("diary-status-log"),
        statusImport: document.getElementById("diary-status-import"),
      },
      pain: {
        file: "pain.json",
        logsTable: document.getElementById("pain-table"),
        statusLog: document.getElementById("pain-status-log"),
        statusImport: document.getElementById("pain-status-import"),
      },
    };
    const dataStore = { diary: null, pain: null };
    const logFilters = { diary: {}, pain: {} };
    const authUI = {
      email: document.getElementById("auth-email"),
      pass: document.getElementById("auth-pass"),
      status: document.getElementById("auth-status"),
      debug: document.getElementById("auth-debug"),
      loginBtn: document.getElementById("auth-login"),
      logoutBtn: document.getElementById("auth-logout"),
      hubBtn: document.getElementById("go-hub"),
    };
    const backupUI = {
      importInput: document.getElementById("import-backup-input"),
      exportBtn: document.getElementById("export-backup-button"),
      purgeBtn: document.getElementById("full-purge-button"),
      importXlsx: document.getElementById("import-xlsx-input"),
      exportXlsx: document.getElementById("export-xlsx-button"),
      status: document.getElementById("backup-status"),
      errorBox: document.getElementById("backup-error"),
    };
    const appMain = document.getElementById("app-main");
    let isAuthed = false;
    function apiFetch(url, options = {}) {
      const opts = { credentials: "include", ...options };
      opts.headers = { ...(options.headers || {}) };
      let finalUrl = url;
      if (url.startsWith("/")) {
        // Keep requests scoped to the app root (works even when loaded at /myhealth without a trailing slash)
        const path = window.location.pathname || "";
        const match = path.match(/^\/[^/]+/);
        const scopedBase = match ? match[0] : "";
        finalUrl = `${scopedBase}${url}`;
      }
      return fetch(finalUrl, opts);
    }

    async function safeParseJson(res) {
      const text = await res.text();
      try {
        return JSON.parse(text);
      } catch (err) {
        return text;
      }
    }
    function setAuthStatus(message, ok = false) {
      if (!authUI.status) return;
      authUI.status.innerHTML = message
        ? `<span class="${ok ? "ok" : "err"}">${ok ? "OK" : "Error"}:</span> ${escapeHtml(message)}`
        : "";
    }
    function setAuthDebug(text) {
      if (!authUI.debug) return;
      authUI.debug.textContent = text || "";
      authUI.debug.classList.toggle("hidden", !text);
    }
    function setAuthVisibility(authed) {
      isAuthed = authed;
      const toHide = [authUI.email, authUI.pass, authUI.loginBtn, authUI.status];
      toHide.forEach((el) => el?.classList.toggle("hidden", authed));
      authUI.logoutBtn?.classList.toggle("hidden", !authed);
      authUI.hubBtn?.classList.toggle("hidden", !authed);
      const authCard = document.querySelector(".auth-card");
      authCard?.classList.toggle("hidden", authed);
      if (!authed) {
        setAuthStatus("");
      }
    }
    function setAppVisible(isAuthed) {
      if (appMain) appMain.classList.toggle("hidden", !isAuthed);
    }
    function resetAppState() {
      dataStore.diary = null;
      dataStore.pain = null;
      ["diary", "pain"].forEach((kind) => {
        const table = datasets[kind]?.logsTable;
        if (table) table.innerHTML = "";
        setStatus(kind, "", true, "logs");
        setStatus(kind, "", true, "import");
      });
      const dashCards = document.getElementById("dash-cards");
      const dashGraphs = document.getElementById("dash-graphs");
      if (dashCards) dashCards.innerHTML = "";
      if (dashGraphs) dashGraphs.innerHTML = "";
    }
    const REQUIRED = {
      diary: ["date", "hour", "mood level", "depression", "anxiety", "description", "gratitude", "reflection"],
      pain: [
        "date",
        "hour",
        "pain level",
        "fatigue level",
        "symptoms",
        "area",
        "activities",
        "habits",
        "coffee",
        "other",
        "medicines",
        "note",
      ],
    };
    const ALIASES = {
      diary: {
        "date": ["date", "file name"],
        "hour": ["hour", "time"],
      },
      pain: {
        "date": ["date", "file name"],
        "hour": ["hour", "time"],
        "pain level": ["pain level", "pain"],
        "fatigue level": ["fatigue level", "fatigue"],
        "habits": ["habits", "good sleep", "healthy food", "sleep"],
        "other": ["other", ">6h day byte", ">1h masturbation", "<1h masturbation", "cum"],
        "coffee": ["coffee"],
        "medicines": ["medicines"],
      },
    };
    const LONG_TEXT_FIELDS = [
      "description",
      "gratitude",
      "reflection",
      "note",
      "medicines",
      "symptoms",
      "activities",
      "area",
      "habits",
      "other",
    ];
    let entryTabSetter = null;
    const optionFields = ["area", "symptoms", "activities", "medicines", "habits", "other"];
    const OPTION_CACHE_KEY = "myhealth:painOptions:v2";
    const optionsCache = {
      area: [],
      symptoms: [],
      activities: [],
      medicines: [],
      habits: [],
      other: [],
    };
    const removedOptions = {
      area: [],
      symptoms: [],
      activities: [],
      medicines: [],
      habits: [],
      other: [],
    };
    const cardEmojiMap = {
      "Journal entries": "üìí",
      "Pain entries": "üìì",
      "Mood avg": "üôÇ",
      "Depression avg": "üòî",
      "Anxiety avg": "üò®",
      "Pain avg": "ü§ï",
      "Fatigue avg": "ü•±",
    };
    const EMOJI_CHOICES = ["üìí", "üìì", "üôÇ", "üòî", "üò®", "ü§ï", "ü•±", "üòä", "üí™", "üß†", "ü©∫", "üåø", "‚≠ê", "üî•", "‚ú®"];
    let emojiPickerEl = null;
    let emojiScriptLoading = null;

    function closeEmojiPicker() {
      if (emojiPickerEl) {
        emojiPickerEl.remove();
        emojiPickerEl = null;
      }
    }

    function ensureEmojiPickerLib() {
      if (window.EmojiMart && window.EmojiMart.Picker) {
        return Promise.resolve(window.EmojiMart.Picker);
      }
      if (emojiScriptLoading) return emojiScriptLoading;
      emojiScriptLoading = new Promise((resolve, reject) => {
        const cssId = "emoji-mart-css";
        if (!document.getElementById(cssId)) {
          const link = document.createElement("link");
          link.id = cssId;
          link.rel = "stylesheet";
          link.href = "https://cdn.jsdelivr.net/npm/emoji-mart@5.6.0/dist/browser.css";
          document.head.appendChild(link);
        }
        const script = document.createElement("script");
        script.src = "https://cdn.jsdelivr.net/npm/emoji-mart@5.6.0/dist/browser.js";
        script.async = true;
        script.onload = () => {
          if (window.EmojiMart && window.EmojiMart.Picker) {
            resolve(window.EmojiMart.Picker);
          } else {
            reject(new Error("Emoji picker library did not load"));
          }
        };
        script.onerror = () => reject(new Error("Failed to load emoji picker library"));
        document.head.appendChild(script);
      });
      return emojiScriptLoading;
    }

    function openEmojiPicker(label, anchor) {
      const fallback = () => {
        closeEmojiPicker();
        const picker = document.createElement("div");
        picker.className = "emoji-picker";
        EMOJI_CHOICES.forEach((emoji) => {
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "emoji-choice";
          btn.textContent = emoji;
          btn.addEventListener("click", (e) => {
            e.stopPropagation();
            cardEmojiMap[label] = emoji;
            closeEmojiPicker();
            renderDashboard();
          });
          picker.appendChild(btn);
        });
        const custom = document.createElement("input");
        custom.className = "emoji-input";
        custom.placeholder = "Custom";
        custom.maxLength = 3;
        custom.addEventListener("change", (e) => {
          const val = (e.target.value || "").trim();
          if (val) {
            cardEmojiMap[label] = val;
            closeEmojiPicker();
            renderDashboard();
          }
        });
        picker.appendChild(custom);
        document.body.appendChild(picker);
        const rect = anchor.getBoundingClientRect();
        picker.style.left = `${rect.left + window.scrollX}px`;
        picker.style.top = `${rect.bottom + window.scrollY + 6}px`;
        emojiPickerEl = picker;
        setTimeout(() => {
          const handler = (ev) => {
            if (!emojiPickerEl) return;
            if (emojiPickerEl.contains(ev.target)) return;
            closeEmojiPicker();
          };
          document.addEventListener("click", handler, { once: true });
        }, 0);
      };

      ensureEmojiPickerLib()
        .then((Picker) => {
          closeEmojiPicker();
          const pickerWrap = document.createElement("div");
          pickerWrap.style.position = "absolute";
          const rect = anchor.getBoundingClientRect();
          pickerWrap.style.left = `${rect.left + window.scrollX}px`;
          pickerWrap.style.top = `${rect.bottom + window.scrollY + 6}px`;
          const picker = new Picker({
            theme: "dark",
            skinTonePosition: "none",
            previewPosition: "none",
            onEmojiSelect: (emoji) => {
              cardEmojiMap[label] = emoji.native || emoji.name || "üòä";
              closeEmojiPicker();
              renderDashboard();
            },
          });
          pickerWrap.appendChild(picker);
          document.body.appendChild(pickerWrap);
          emojiPickerEl = pickerWrap;
          setTimeout(() => {
            const handler = (ev) => {
              if (!emojiPickerEl) return;
              if (emojiPickerEl.contains(ev.target)) return;
              closeEmojiPicker();
            };
            document.addEventListener("click", handler, { once: true });
          }, 0);
        })
        .catch(() => fallback());
    }

    function loadSavedOptionCache() {
      try {
        const raw = localStorage.getItem(OPTION_CACHE_KEY);
        if (!raw) {
          return { options: {}, removed: {} };
        }
        const parsed = JSON.parse(raw);
        if (!parsed || typeof parsed !== "object") {
          return { options: {}, removed: {} };
        }
        return {
          options: parsed.options || {},
          removed: parsed.removed || {},
        };
      } catch (err) {
        return { options: {}, removed: {} };
      }
    }

    function persistOptionCache() {
      try {
        localStorage.setItem(
          OPTION_CACHE_KEY,
          JSON.stringify({ options: optionsCache, removed: removedOptions })
        );
      } catch (err) {
        // best effort; ignore
      }
    }

    function wireAuthForm() {
      if (authUI.loginBtn) {
        authUI.loginBtn.addEventListener("click", () => doLogin());
      }
      if (authUI.logoutBtn) {
        authUI.logoutBtn.addEventListener("click", () => doLogout());
      }
    }

    async function doLogin() {
      const email = authUI.email?.value?.trim();
      const password = authUI.pass?.value || "";
      if (!email || !password) {
        setAuthStatus("Email and password required");
        return;
      }
      try {
        const res = await apiFetch("/api/files/login", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ email, password }),
        });
        const data = await safeParseJson(res);
        if (!res.ok) {
          setAuthDebug(`HTTP ${res.status}\n${typeof data === "string" ? data : JSON.stringify(data)}`);
          throw new Error((data && data.error) || (typeof data === "string" ? data : "") || "Login failed");
        }
        setAuthStatus(`Logged in as ${data.email || email}`, true);
        setAuthDebug("");
        if (authUI.pass) authUI.pass.value = "";
        setAuthVisibility(true);
        setAppVisible(true);
        await fetchExisting("diary");
        await fetchExisting("pain");
        renderDashboard();
      } catch (err) {
        setAuthStatus(err.message || "Login failed");
        if (!authUI.debug?.textContent) {
          setAuthDebug(err?.stack || err?.message || String(err));
        }
      }
    }

    async function doLogout() {
      try {
        await apiFetch("/api/files/logout", { method: "POST" });
        setAuthStatus("Logged out", true);
        resetAppState();
        setAppVisible(false);
        setAuthVisibility(false);
      } catch (err) {
        setAuthStatus(err.message || "Logout failed");
      }
    }

    function buildOptionCacheFromStore() {
      const saved = loadSavedOptionCache();
      optionFields.forEach((field) => {
        const derived = collectOptions(field);
        const stored = Array.isArray(saved.options?.[field]) ? saved.options[field] : [];
        const removed = new Set(Array.isArray(saved.removed?.[field]) ? saved.removed[field] : []);
        const merged = dedupe([
          ...stored,
          ...(derived || []).filter((v) => !removed.has(v)),
        ]);
        optionsCache[field] = merged;
        removedOptions[field] = Array.from(removed);
      });
      persistOptionCache();
    }

    function wireJournalForm() {
      const form = document.getElementById("journal-form");
      const status = document.getElementById("journal-form-status");
      if (!form) return;
      const setStatusMsg = (msg, ok = false) => {
        if (!status) return;
        status.innerHTML = msg ? `<span class="${ok ? "ok" : "err"}">${ok ? "Saved" : "Error"}:</span> ${escapeHtml(msg)}` : "";
      };
      const setDefaultDate = () => {
        const input = form.querySelector('input[name="journal-date"]');
        if (input) {
          const now = new Date();
          const localIso = new Date(now.getTime() - now.getTimezoneOffset() * 60000).toISOString().slice(0, 16);
          input.value = localIso;
        }
      };
      setDefaultDate();

      const cancelBtn = document.getElementById("journal-cancel-btn");
      if (cancelBtn) {
        cancelBtn.addEventListener("click", () => {
          resetEditState();
        });
      }

      form.addEventListener("submit", async (e) => {
        e.preventDefault();
        const data = new FormData(form);
        const toParts = (val) => {
          const fallback = new Date();
          const parsed = val ? new Date(val) : fallback;
          const good = parsed.toString() !== "Invalid Date" ? parsed : fallback;
          const iso = new Date(good.getTime() - good.getTimezoneOffset() * 60000).toISOString();
          return { date: iso.slice(0, 10), time: iso.slice(11, 16) };
        };
        const parts = toParts(data.get("journal-date"));
        const row = {
          "date": parts.date,
          "hour": parts.time,
          "mood level": data.get("journal-mood") || "",
          "depression": data.get("journal-depression") || "",
          "anxiety": data.get("journal-anxiety") || "",
          "description": data.get("journal-description") || "",
          "gratitude": data.get("journal-gratitude") || "",
          "reflection": data.get("journal-reflection") || "",
        };
        const parsed = { headers: REQUIRED.diary, rows: [row] };
        try {
          if (editingEntry.kind === "diary" && editingEntry.idx !== null) {
            // Update existing
            const rows = [...dataStore.diary.rows];
            rows[editingEntry.idx] = row;
            await saveRows("diary", rows);
            setStatusMsg("Updated journal entry", true);
            resetEditState();
          } else {
            // Create new
            await persist("diary", parsed, "journal form");
            setStatusMsg("Saved journal entry", true);
            form.reset();
            setDefaultDate();
          }
        } catch (err) {
          setStatusMsg(err.message || "Failed to save journal entry", false);
        }
      });
    }

    async function fetchExisting(kind, opts = {}) {
      const { silentAuthFail = false } = opts;
      const cfg = datasets[kind];
      try {
        const res = await apiFetch(`/api/files/${cfg.file}`);
        if (res.status === 401) {
          if (!silentAuthFail) setAuthStatus("Please log in to load data");
          const body = await res.text();
          setBackupError(`401 unauthorized loading ${cfg.file}\n${body}`);
          return false;
        }
        if (!res.ok) {
          const body = await res.text();
          setBackupError(`Error ${res.status} loading ${cfg.file}\n${body}`);
          return false;
        }
        const data = await res.json();
        if (data && data.rows && data.headers) {
          const normalized = normalizeDataset(data, kind);
          const sortedRows = sortRowsByDateTime(normalized.data.rows, normalized.data.headers);
          const updated = { ...normalized.data, rows: sortedRows };
          dataStore[kind] = updated;
          renderLog(kind);
          setStatus(kind, `Loaded ${updated.rows.length} rows from ${cfg.file}`, true, "logs");
          if (normalized.changed) {
            await persistNormalized(kind, updated);
          }
          if (kind === "pain") {
            buildOptionCacheFromStore();
            renderPainOptionButtons();
          }
          renderDashboard();
          return true;
        }
      } catch (err) {
        console.warn("Load error", err);
      }
      return false;
    }

    async function ensureLoaded(kind) {
      if (dataStore[kind] && dataStore[kind].headers && dataStore[kind].rows) {
        return true;
      }
      return fetchExisting(kind);
    }

    function parseXlsx(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const data = new Uint8Array(e.target.result);
            const workbook = XLSX.read(data, { type: "array" });
            resolve(workbook);
          } catch (err) {
            reject(err);
          }
        };
        reader.onerror = (err) => reject(err);
        reader.readAsArrayBuffer(file);
      });
    }

    function sheetToDataset(sheet) {
      if (!sheet) return null;
      const rows = XLSX.utils.sheet_to_json(sheet);
      if (!rows || !rows.length) return null;
      const headers = Object.keys(rows[0]);
      const normalizedRows = rows.map((row) => {
        const clean = {};
        headers.forEach((h) => { clean[h] = row[h] ?? ""; });
        return clean;
      });
      return { headers, rows: normalizedRows };
    }

    function datasetToSheet(dataset) {
      if (!dataset?.headers || !dataset.rows) return XLSX.utils.json_to_sheet([]);
      const objs = dataset.rows.map((row) => {
        const obj = {};
        dataset.headers.forEach((h) => { obj[h] = row[h] ?? ""; });
        return obj;
      });
      return XLSX.utils.json_to_sheet(objs);
    }

    function setStatus(kind, message, ok = false, target = "logs") {
      const el = target === "import" ? datasets[kind].statusImport : datasets[kind].statusLog;
      if (!el) return;
      el.innerHTML = message ? `<span class="${ok ? "ok" : "err"}">${ok ? "OK" : "Error"}:</span> ${message}` : "";
    }

    function setBackupStatus(message, ok = false) {
      if (!backupUI.status) return;
      backupUI.status.innerHTML = message
        ? `<span class="${ok ? "ok" : "err"}">${ok ? "OK" : "Error"}:</span> ${escapeHtml(message)}`
        : "";
      if (backupUI.errorBox && ok) {
        backupUI.errorBox.classList.add("hidden");
        backupUI.errorBox.textContent = "";
      }
    }

    function setBackupError(message) {
      if (!backupUI.errorBox) return;
      backupUI.errorBox.textContent = message || "";
      backupUI.errorBox.classList.toggle("hidden", !message);
    }

    function wireLogFilters(kind) {
      const cfg = datasets[kind];
      if (!cfg?.logsTable) return;
      cfg.logsTable.querySelectorAll(".filter-input").forEach((input) => {
        const field = input.dataset.filterField;
        input.value = logFilters[kind]?.[field] || "";
        input.addEventListener("input", (e) => {
          logFilters[kind][field] = e.target.value || "";
          renderLog(kind);
        });
      });
    }

    function showPopup(message, ok = true) {
      let toast = document.getElementById("toast");
      if (!toast) {
        toast = document.createElement("div");
        toast.id = "toast";
        toast.className = "toast";
        document.body.appendChild(toast);
      }
      toast.className = `toast ${ok ? "success" : "error"}`;
      toast.textContent = message;
      requestAnimationFrame(() => toast.classList.add("show"));
      setTimeout(() => toast.classList.remove("show"), 2800);
    }

    function sortRowsByDateTime(rows, headers) {
      const dKey = findHeader(headers, "date") || "date";
      const tKey = findHeader(headers, "hour") || "hour";
      return [...rows].sort((a, b) => {
        const aDate = new Date(`${a?.[dKey] || ""}T${(a?.[tKey] || "00:00").slice(0, 5)}`);
        const bDate = new Date(`${b?.[dKey] || ""}T${(b?.[tKey] || "00:00").slice(0, 5)}`);
        const aTs = aDate.toString() === "Invalid Date" ? 0 : aDate.getTime();
        const bTs = bDate.toString() === "Invalid Date" ? 0 : bDate.getTime();
        return bTs - aTs;
      });
    }

    function sortRowsWithIndex(rows, headers) {
      const dKey = findHeader(headers, "date") || "date";
      const tKey = findHeader(headers, "hour") || "hour";
      return rows
        .map((row, idx) => ({ row, idx }))
        .sort((a, b) => {
          const aDate = new Date(`${a.row?.[dKey] || ""}T${(a.row?.[tKey] || "00:00").slice(0, 5)}`);
          const bDate = new Date(`${b.row?.[dKey] || ""}T${(b.row?.[tKey] || "00:00").slice(0, 5)}`);
          const aTs = aDate.toString() === "Invalid Date" ? 0 : aDate.getTime();
          const bTs = bDate.toString() === "Invalid Date" ? 0 : bDate.getTime();
          return bTs - aTs;
        });
    }

    function renderTable(kind, headers, rows, withActions = false, limit = null) {
      const cfg = datasets[kind];
      const isLogView = withActions; // Usually true for the main log view

      if (!headers || !rows) {
        cfg.logsTable.innerHTML = "";
        return;
      }

      const sortedRows = sortRowsWithIndex(rows, headers);
      const globalFilter = (logFilters[kind]?.['global'] || "").toLowerCase();
      const filteredRows = sortedRows.filter(({ row }) => {
        if (!globalFilter) return true;
        return Object.values(row).some(v => String(v).toLowerCase().includes(globalFilter));
      });

      const displayRows = limit ? filteredRows.slice(0, limit) : filteredRows;

      // If it's the dashboard/preview, maybe keep it simple? But user asked for "logs of both apps". 
      // Assuming this replaces the main log tables.

      // Filter Inputs for main view
      let filterHtml = "";
      if (isLogView) {
        // Simplified filter: just one global search or maybe just date?
        // For now, let's keep the date range filter in dashboard, 
        // but here we might want a text filter provided by the existing filter inputs if we keep them.
        // But the card view makes per-column filtering hard.
        // Let's add a generic search input if needed, or rely on distinct filters.
        // The previous filter row had per-column inputs. 
        // Let's revert to a single "Search" input for simplicity in card view?
        // Or just skip filters for now as user didn't specify, but removing them might be bad.
        // I'll add a simple "Filter by content" input above the grid.

        filterHtml = `
         <div class="filter-bar">
             <input type="text" id="filter-${kind}" placeholder="Search logs..." style="width: 100%; padding: 8px; border-radius: 8px; border: 1px solid var(--border); background: var(--card); color: var(--text);">
         </div>`;
      }

      const gridHtml = `
        <div class="log-grid">
          ${displayRows.map(({ row, idx: originalIdx }) => {
        const dateKey = findHeader(headers, "date") || "date";
        const timeKey = findHeader(headers, "hour") || "hour";
        const dateStr = row[dateKey] || "No date";
        const timeStr = row[timeKey] || "";

        // Format nice date if possible
        let niceDate = dateStr;
        try {
          const d = new Date(dateStr);
          if (!isNaN(d)) niceDate = d.toLocaleDateString(undefined, { month: 'short', day: 'numeric' });
        } catch (e) { }

        return `
              <div class="log-card">
                <div class="log-card-header">
                  <span>${escapeHtml(niceDate)}</span>
                  <span style="color:var(--accent);">${escapeHtml(timeStr)}</span>
                </div>
                ${isLogView ? `
                <div class="log-card-actions">
                  <button class="nav-btn small" data-edit-row="${originalIdx}" data-kind="${kind}" title="Edit">
                    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>
                  </button>
                  <button class="nav-btn danger small" data-delete-row="${originalIdx}" data-kind="${kind}" title="Delete">
                     <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/></svg>
                  </button>
                </div>
                ` : ''}
              </div>
            `;
      }).join("")}
        </div>
      `;

      cfg.logsTable.innerHTML = (isLogView ? filterHtml : "") + gridHtml;

      // Update count span in header
      const countSpanId = kind === 'pain' ? 'pain-count' : 'diary-count';
      const countSpan = document.getElementById(countSpanId);
      if (countSpan) {
        countSpan.textContent = `${displayRows.length} entries`;
      }

      if (isLogView) {
        // Wire search
        const searchInput = document.getElementById(`filter-${kind}`);
        if (searchInput) {
          // Restore filter value
          // We need a place to store this new single filter
          // Re-using logFilters[kind]['global'] for now?
          searchInput.value = logFilters[kind]?.['global'] || "";
          searchInput.addEventListener("input", (e) => {
            if (!logFilters[kind]) logFilters[kind] = {};
            logFilters[kind]['global'] = e.target.value;
            // We need to re-run renderTable, but renderTable uses logFilters to filter... 
            // I need to update the filter logic above to handle 'global'
            renderLog(kind);
          });
        }
        wireRowActions(kind);
      }
    }

    // Quick patch for global filter support in the filter block above
    // I will replace the filter logic block in the next edit or include it here.
    // Let's rewrite the filter block inside this function:
    /*
      const globalFilter = (logFilters[kind]?.['global'] || "").toLowerCase();
      const filteredRows = sortedRows.filter(({ row }) => {
        if (!globalFilter) return true;
        // Search all values
        return Object.values(row).some(v => String(v).toLowerCase().includes(globalFilter));
      });
    */


    function escapeHtml(str) {
      return String(str)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }

    function parseCSV(text) {
      const rows = [];
      let current = [];
      let value = "";
      let inQuotes = false;
      for (let i = 0; i < text.length; i++) {
        const c = text[i];
        if (inQuotes) {
          if (c === '"') {
            if (text[i + 1] === '"') {
              value += '"';
              i++;
            } else {
              inQuotes = false;
            }
          } else {
            value += c;
          }
        } else {
          if (c === '"') {
            inQuotes = true;
          } else if (c === ",") {
            current.push(value);
            value = "";
          } else if (c === "\n") {
            current.push(value);
            rows.push(current);
            current = [];
            value = "";
          } else if (c === "\r") {
            continue;
          } else {
            value += c;
          }
        }
      }
      if (value !== "" || current.length) {
        current.push(value);
        rows.push(current);
      }
      const headers = rows.shift() || [];
      const objects = rows.filter(r => r.length && r.some(cell => cell.trim() !== "")).map(r => {
        const obj = {};
        headers.forEach((h, idx) => obj[h.trim()] = r[idx] ?? "");
        return obj;
      });
      return { headers, rows: objects };
    }

    async function handleFile(kind, file) {
      const cfg = datasets[kind];
      if (!file) return;
      try {
        const text = await file.text();
        const parsed = parseCSV(text);
        if (!parsed.headers.length) throw new Error("No headers detected");
        const normalized = normalizeParsed(parsed, kind);
        const validateMsg = validateHeaders(kind, normalized.headers);
        if (validateMsg) throw new Error(validateMsg);
        const result = await persist(kind, normalized, file.name);
        setStatus(kind, `Imported ${result.added} new, ${result.skipped} existing (source: ${file.name})`, true, "import");
        showPopup(`Imported ${result.added} new, ${result.skipped} already present`, true);
      } catch (err) {
        setStatus(kind, err.message || "Failed to parse", false, "import");
        showPopup(err.message || "Import failed", false);
      }
    }

    function normalizeHeaderName(h) {
      return h
        .replace(/^\uFEFF/, "")
        .toLowerCase()
        .replace(/\u00a0/g, " ") // nbsp to space
        .replace(/[-_‚Äì‚Äî]+/g, " ")
        .replace(/\s+/g, " ")
        .trim();
    }

    function validateHeaders(kind, headers) {
      const expected = REQUIRED[kind];
      if (!expected) return "";
      const normalized = headers.map(normalizeHeaderName);
      const set = new Set(normalized);
      const aliasMap = ALIASES[kind] || {};
      const missing = [];
      expected.forEach(req => {
        const aliases = aliasMap[req] || [req];
        const found = aliases.some(a => set.has(normalizeHeaderName(a)));
        if (!found) missing.push(req);
      });
      return missing.length ? `Missing columns for ${kind}: ${missing.join(", ")}` : "";
    }

    function findHeader(headers, target) {
      const wanted = normalizeHeaderName(target);
      for (const h of headers) {
        if (normalizeHeaderName(h) === wanted) return h;
      }
      return null;
    }

    function normalizeTimestamp(val) {
      const raw = String(val ?? "").trim();
      if (!raw) return "";
      const hasTime = raw.includes("T") || raw.includes(" ");
      if (hasTime) return raw.replace(" ", "T");
      return raw;
    }

    function normalizeRows(headers, rows, kind) {
      const createdKey = findHeader(headers, "created time");
      const fileKey = findHeader(headers, "file name");
      const dateKey = findHeader(headers, "date") || fileKey || createdKey || "date";
      const hourKey = findHeader(headers, "hour") || findHeader(headers, "time");
      const habitsKey = findHeader(headers, "habits");
      const goodKey = findHeader(headers, "good sleep");
      const healthyKey = findHeader(headers, "healthy food");
      const otherKey = findHeader(headers, "other");
      const flagDefs = [
        { key: findHeader(headers, ">6h day byte"), label: ">6h day byte" },
        { key: findHeader(headers, ">1h masturbation"), label: ">1h masturbation" },
        { key: findHeader(headers, "<1h masturbation"), label: "<1h masturbation" },
        { key: findHeader(headers, "cum"), label: "cum" },
      ];

      const allowed = kind && REQUIRED[kind] ? REQUIRED[kind] : null;
      const allowedNormalized = allowed ? allowed.map(normalizeHeaderName) : null;
      const cleanedHeaders = headers.filter((h) => {
        const norm = normalizeHeaderName(h);
        if (allowedNormalized) return allowedNormalized.includes(norm);
        return ![
          "created time",
          "file name",
          "date",
          "time",
          "hour",
          "habits",
          "good sleep",
          "healthy food",
          ">6h day byte",
          ">1h masturbation",
          "<1h masturbation",
          "cum",
        ].includes(norm);
      });
      const normalizedHeaders = [];
      const desiredOrder =
        allowed ||
        [
          "date",
          "hour",
          "pain level",
          "fatigue level",
          "symptoms",
          "area",
          "activities",
          "habits",
          "coffee",
          "other",
          "medicines",
          "note",
        ];
      [...desiredOrder, ...cleanedHeaders].forEach((h) => {
        const norm = normalizeHeaderName(h);
        if (!normalizedHeaders.some((x) => normalizeHeaderName(x) === norm)) {
          normalizedHeaders.push(h === "file name" ? "date" : h);
        }
      });

      let changed = normalizeHeaderName(createdKey || "") === "created time" || !!fileKey;
      const normalizedRows = (rows || []).map((row) => {
        const rawFile = fileKey ? row[fileKey] : "";
        const rawCreated = createdKey ? row[createdKey] : "";
        const rawDate = dateKey ? row[dateKey] : "";
        const rawHour = hourKey ? row[hourKey] : "";
        const rawHabits = habitsKey ? row[habitsKey] : "";
        const rawGood = goodKey ? row[goodKey] : "";
        const rawHealthy = healthyKey ? row[healthyKey] : "";

        const preferred = rawDate || rawFile || rawCreated || "";
        const normalizedValue = normalizeTimestamp(preferred);
        let datePart = normalizedValue;
        let hourPart = "";
        if (normalizedValue.includes("T")) {
          const [d, t] = normalizedValue.split("T");
          datePart = d;
          hourPart = (t || "").slice(0, 5);
        }
        if (!hourPart && rawHour) {
          hourPart = String(rawHour).slice(0, 5);
        }
        if (!hourPart) hourPart = "21:00";

        const next = { ...row, date: datePart, hour: hourPart };
        if (kind === "pain") {
          if (habitsKey) delete next[habitsKey];
          if (goodKey) delete next[goodKey];
          if (healthyKey) delete next[healthyKey];
          flagDefs.forEach((f) => {
            if (f.key && f.key in next) delete next[f.key];
          });
          if (otherKey && otherKey in next) delete next[otherKey];

          const habitTokens = new Set();
          const addTokens = (val) => {
            String(val || "")
              .split(",")
              .map((s) => s.trim().toLowerCase())
              .filter((s) => s && !["false", "true", "yes", "1", "no", "0"].includes(s))
              .forEach((s) => habitTokens.add(s));
          };
          addTokens(rawHabits);
          addTokens(rawGood);
          addTokens(rawHealthy);
          const goodYes = habitTokens.has("good sleep") || /^yes|true|1$/i.test(String(rawGood || "").trim());
          const healthyYes =
            habitTokens.has("healthy food") || /^yes|true|1$/i.test(String(rawHealthy || "").trim());
          const habitList = [];
          if (goodYes) habitList.push("good sleep");
          if (healthyYes) habitList.push("healthy food");
          const extraHabits = Array.from(habitTokens).filter(
            (t) => t && t !== "good sleep" && t !== "healthy food"
          );
          if (extraHabits.length) habitList.push(...extraHabits);
          next["habits"] = habitList.join(", ");

          const otherTokens = new Set();
          const addOther = (label, val) => {
            const v = String(val || "").trim();
            if (!v) return;
            const lower = v.toLowerCase();
            if (["yes", "true", "1"].includes(lower)) {
              otherTokens.add(label);
            } else if (!["false", "no", "0"].includes(lower)) {
              otherTokens.add(v);
            }
          };
          flagDefs.forEach((f) => addOther(f.label, f.key ? row[f.key] : ""));
          if (otherKey) {
            String(row[otherKey] || "")
              .split(",")
              .map((s) => s.trim())
              .filter((s) => s && !["false", "true", "yes", "1", "no", "0"].includes(s.toLowerCase()))
              .forEach((s) => otherTokens.add(s));
          }
          next["other"] = Array.from(otherTokens).join(", ");
          if (allowedNormalized) {
            Object.keys(next).forEach((key) => {
              if (!allowedNormalized.includes(normalizeHeaderName(key))) {
                delete next[key];
              }
            });
          }
        } else if (allowedNormalized) {
          // strip any fields not in allowed when not pain
          Object.keys(next).forEach((key) => {
            if (!allowedNormalized.includes(normalizeHeaderName(key))) {
              delete next[key];
            }
          });
        }

        if (fileKey && fileKey in next) delete next[fileKey];
        if (createdKey && createdKey in next) delete next[createdKey];
        if (hourKey && hourKey !== "hour" && hourKey in next) delete next[hourKey];

        if (
          next.date !== rawDate ||
          (fileKey && rawFile && next.date !== rawFile) ||
          (createdKey && rawCreated && next.date !== rawCreated) ||
          next.hour !== rawHour ||
          (kind === "pain" && (next.habits !== rawHabits || next.other !== (otherKey ? row[otherKey] : "")))
        ) {
          changed = true;
        }
        return next;
      });
      return { headers: normalizedHeaders, rows: normalizedRows, changed };
    }

    function collectOptions(field) {
      const store = dataStore.pain;
      const options = new Set();
      if (store?.rows?.length) {
        const key = findHeader(store.headers, field) || field;
        store.rows.forEach((row) => {
          const val = row?.[key];
          if (!val) return;
          String(val)
            .split(",")
            .map((s) => s.trim())
            .filter((s) => s && !["true", "false", "yes", "no", "0", "1"].includes(s.toLowerCase()))
            .forEach((s) => options.add(s));
        });
      }
      return Array.from(options);
    }

    const logCollapsed = { diary: false, pain: false };
    let editingState = { kind: null, idx: null, draft: null };

    function renderLog(kind) {
      const data = dataStore[kind];
      if (!data?.headers || !data.rows) return;
      const wrap = datasets[kind]?.logsTable;
      renderTable(kind, data.headers, data.rows, true, null);
    }

    function renderOptionButtons(field, containerId, preselectAll = false) {
      const el = document.getElementById(containerId);
      if (!el) return;
      const values = optionsCache[field] || [];
      if (!values.length) {
        el.innerHTML = `<span style="color:var(--muted); font-size:13px;">No ${field} options yet</span>`;
        return;
      }
      el.innerHTML = values
        .map(
          (v) =>
            `<button type="button" class="chip-btn${preselectAll ? " active" : ""}" data-value="${escapeHtml(
              v
            )}">${escapeHtml(v)}</button>`
        )
        .join("");
      el.querySelectorAll(".chip-btn").forEach((btn) => {
        btn.addEventListener("click", () => btn.classList.toggle("active"));
      });
    }

    function wireRowActions(kind) {
      const cfg = datasets[kind];
      if (!cfg?.logsTable) return;
      cfg.logsTable.querySelectorAll("[data-edit-row]").forEach((btn) => {
        btn.onclick = () => editRow(kind, parseInt(btn.dataset.editRow, 10));
      });
      cfg.logsTable.querySelectorAll("[data-delete-row]").forEach((btn) => {
        btn.onclick = () => deleteRow(kind, parseInt(btn.dataset.deleteRow, 10));
      });
      cfg.logsTable.querySelectorAll("[data-save-row]").forEach((btn) => {
        // Obsolete
      });
      cfg.logsTable.querySelectorAll("[data-cancel-row]").forEach((btn) => {
        // Obsolete
      });

    }

    function sanitizeRowForHeaders(row, headers) {
      const clean = {};
      headers.forEach((h) => {
        clean[h] = row[h] ?? "";
      });
      return clean;
    }

    async function saveRows(kind, rows) {
      const headers = dataStore[kind]?.headers || REQUIRED[kind] || [];
      const normalized = normalizeRows(headers, rows, kind);
      const sortedRows = sortRowsByDateTime(normalized.rows, normalized.headers);
      const payload = {
        source: "manual edit",
        imported_at: new Date().toISOString(),
        headers: normalized.headers,
        rows: sortedRows,
      };
      try {
        const res = await apiFetch(`/api/files/${datasets[kind].file}`, {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });
        if (res.status === 401) throw new Error("Please log in to save");
        if (!res.ok) throw new Error(`Server returned ${res.status}`);
        dataStore[kind] = payload;
        renderLog(kind);
        setStatus(kind, "Saved edits", true, "logs");
        if (kind === "pain") {
          buildOptionCacheFromStore();
          renderPainOptionButtons();
        }
        renderDashboard();
      } catch (err) {
        setStatus(kind, err.message || "Failed to save edits", false, "logs");
      }
    }



    // New editing state: tracks entry kind and index
    let editingEntry = { kind: null, idx: null };

    // Helper: Select options in a container by values string
    function selectOptions(containerId, valuesString) {
      const container = document.getElementById(containerId);
      if (!container) return;
      // Deselect all first
      container.querySelectorAll(".chip-btn").forEach(btn => btn.classList.remove("active"));
      if (!valuesString) return;
      const values = String(valuesString).split(",").map(s => s.trim().toLowerCase());
      container.querySelectorAll(".chip-btn").forEach(btn => {
        if (values.includes(btn.dataset.value.toLowerCase())) {
          btn.classList.add("active");
        }
      });
    }

    function populatePainForm(row) {
      const form = document.getElementById("pain-form");
      if (!form) return;

      const dateKey = findHeader(Object.keys(row), "date") || "date";
      const timeKey = findHeader(Object.keys(row), "hour") || "hour";
      const dateVal = row[dateKey];
      const timeVal = row[timeKey];

      // Combine date + time for datetime-local input
      if (dateVal) {
        const time = timeVal || "21:00";
        const iso = `${dateVal}T${time.slice(0, 5)}`;
        const input = form.querySelector('input[name="pain-date"]');
        if (input) input.value = iso;
      }

      form.querySelector('input[name="pain-level"]').value = row["pain level"] || "";
      form.querySelector('input[name="fatigue-level"]').value = row["fatigue level"] || "";
      form.querySelector('textarea[name="pain-note"]').value = row["note"] || "";
      form.querySelector('input[name="coffee-count"]').value = row["coffee"] || "";

      selectOptions("area-options", row["area"]);
      selectOptions("symptoms-options", row["symptoms"]);
      selectOptions("activities-options", row["activities"]);
      selectOptions("medicines-options", row["medicines"]);
      selectOptions("habits-options", row["habits"]);
      selectOptions("other-options", row["other"]);
    }

    function populateJournalForm(row) {
      const form = document.getElementById("journal-form");
      if (!form) return;

      const dateKey = findHeader(Object.keys(row), "date") || "date";
      const timeKey = findHeader(Object.keys(row), "hour") || "hour";
      const dateVal = row[dateKey];
      const timeVal = row[timeKey];

      if (dateVal) {
        const time = timeVal || "21:00";
        const iso = `${dateVal}T${time.slice(0, 5)}`;
        const input = form.querySelector('input[name="journal-date"]');
        if (input) input.value = iso;
      }

      form.querySelector('input[name="journal-mood"]').value = row["mood level"] || "";
      form.querySelector('input[name="journal-depression"]').value = row["depression"] || "";
      form.querySelector('input[name="journal-anxiety"]').value = row["anxiety"] || "";
      form.querySelector('textarea[name="journal-description"]').value = row["description"] || "";
      form.querySelector('textarea[name="journal-gratitude"]').value = row["gratitude"] || "";
      form.querySelector('textarea[name="journal-reflection"]').value = row["reflection"] || "";
    }

    function editRow(kind, idx) {
      const rows = dataStore[kind]?.rows || [];
      const row = rows[idx];
      if (!row) return;

      editingEntry = { kind, idx };

      if (kind === "pain") {
        // Switch to Pain tab
        const btn = document.querySelector('button[data-entry="pain"]');
        if (btn) btn.click();
        populatePainForm(row);

        // UI updates
        const submitBtn = document.getElementById("pain-submit-btn");
        if (submitBtn) submitBtn.textContent = "Save Changes";
        const cancelBtn = document.getElementById("pain-cancel-btn");
        if (cancelBtn) cancelBtn.classList.remove("hidden");

        // Scroll to form
        const section = document.getElementById("newlog-section");
        if (section) section.classList.remove("hidden"); // ensure visible
        document.getElementById("pain-form").scrollIntoView({ behavior: "smooth", block: "center" });

      } else if (kind === "diary") {
        // Switch to Journal tab (via autotherapy)
        const autoBtn = document.getElementById("autotherapy-tab");
        if (autoBtn) autoBtn.click();
        const journalBtn = document.querySelector('button[data-autotherapy="journal"]');
        if (journalBtn) journalBtn.click();

        populateJournalForm(row);

        // UI updates
        const submitBtn = document.getElementById("journal-submit-btn");
        if (submitBtn) submitBtn.textContent = "Save Changes";
        const cancelBtn = document.getElementById("journal-cancel-btn");
        if (cancelBtn) cancelBtn.classList.remove("hidden");

        // Scroll to form
        const section = document.getElementById("newlog-section");
        if (section) section.classList.remove("hidden");
        document.getElementById("journal-form").scrollIntoView({ behavior: "smooth", block: "center" });
      }
    }

    function resetEditState() {
      editingEntry = { kind: null, idx: null };

      // Reset Pain UI
      const painSubmit = document.getElementById("pain-submit-btn");
      if (painSubmit) painSubmit.textContent = "Save new entry";
      const painCancel = document.getElementById("pain-cancel-btn");
      if (painCancel) painCancel.classList.add("hidden");
      document.getElementById("pain-form")?.reset();

      // Reset Journal UI
      const journalSubmit = document.getElementById("journal-submit-btn");
      if (journalSubmit) journalSubmit.textContent = "Save journal entry";
      const journalCancel = document.getElementById("journal-cancel-btn");
      if (journalCancel) journalCancel.classList.add("hidden");
      document.getElementById("journal-form")?.reset();

      // Reset chips
      document.querySelectorAll(".chip-btn.active").forEach(btn => btn.classList.remove("active"));
      // re-apply default if needed, or just clear

      // Trigger default date fill
      const painForm = document.getElementById("pain-form");
      if (painForm) {
        const now = new Date();
        const localIso = new Date(now.getTime() - now.getTimezoneOffset() * 60000).toISOString().slice(0, 16);
        const input = painForm.querySelector('input[name="pain-date"]');
        if (input) input.value = localIso;
      }
      const journalForm = document.getElementById("journal-form");
      if (journalForm) {
        const now = new Date();
        const localIso = new Date(now.getTime() - now.getTimezoneOffset() * 60000).toISOString().slice(0, 16);
        const input = journalForm.querySelector('input[name="journal-date"]');
        if (input) input.value = localIso;
      }
    }

    // Obsolete inline functions removed


    function deleteRow(kind, idx) {
      const rows = dataStore[kind]?.rows || [];
      if (!rows[idx]) return;
      const ok = confirm(`Delete row #${idx + 1}?`);
      if (!ok) return;
      const newRows = rows.filter((_, i) => i !== idx);
      saveRows(kind, newRows);
    }

    function wireAutotherapyTabs() {
      const buttons = document.querySelectorAll("[data-autotherapy]");
      const panels = document.querySelectorAll("[data-autotherapy-panel]");
      const setActive = (key) => {
        buttons.forEach((btn) => btn.classList.toggle("active", btn.dataset.autotherapy === key));
        panels.forEach((panel) => panel.classList.toggle("hidden", panel.dataset.autotherapyPanel !== key));
      };
      buttons.forEach((btn) => {
        btn.addEventListener("click", () => setActive(btn.dataset.autotherapy));
      });
    }

    function renderPainOptionButtons() {
      renderOptionButtons("area", "area-options", false);
      renderOptionButtons("symptoms", "symptoms-options", false);
      renderOptionButtons("activities", "activities-options", false);
      renderOptionButtons("medicines", "medicines-options", true);
      renderOptionButtons("habits", "habits-options", false);
      renderOptionButtons("other", "other-options", false);
    }

    function renderOptionEditor(field) {
      const container = document.getElementById(`${field}-editor`);
      if (!container) return;
      const listContainer = document.getElementById(`${field}-options`);
      if (listContainer) listContainer.classList.add("hidden");
      const opts = optionsCache[field] || [];
      const listHtml = opts.length
        ? opts
          .map(
            (v) => `
            <div class="chip-editor-row">
              <span>${escapeHtml(v)}</span>
              <div class="chip-editor-actions">
                <button type="button" data-action="edit" data-value="${escapeHtml(v)}" data-field="${field}">Edit</button>
                <button type="button" data-action="delete" data-value="${escapeHtml(v)}" data-field="${field}">Delete</button>
              </div>
            </div>`
          )
          .join("")
        : `<div style="color:var(--muted); font-size:13px;">No ${escapeHtml(field)} options yet</div>`;
      container.innerHTML = `
        <div class="chip-editor-list">${listHtml}</div>
        <div class="chip-editor-add">
          <input type="text" placeholder="Add ${escapeHtml(field)}" data-new="${field}" />
          <button type="button" data-action="add" data-field="${field}">Add</button>
        </div>
      `;
      container.querySelectorAll("[data-action]").forEach((btn) => {
        btn.addEventListener("click", () => handleEditorAction(btn.dataset));
      });
    }

    function handleEditorAction(dataset) {
      const field = dataset.field;
      if (!field) return;
      const action = dataset.action;
      const current = optionsCache[field] || [];
      if (action === "add") {
        const input = document.querySelector(`input[data-new="${field}"]`);
        const val = input?.value?.trim();
        if (val) {
          optionsCache[field] = dedupe([...current, val]);
          removedOptions[field] = (removedOptions[field] || []).filter((v) => v !== val);
          input.value = "";
          renderOptionEditor(field);
          renderPainOptionButtons();
        }
      } else if (action === "delete") {
        const val = dataset.value;
        optionsCache[field] = current.filter((v) => v !== val);
        if (!removedOptions[field]) removedOptions[field] = [];
        if (!removedOptions[field].includes(val)) removedOptions[field].push(val);
        renderOptionEditor(field);
        renderPainOptionButtons();
      } else if (action === "edit") {
        const val = dataset.value;
        const next = prompt(`Rename ${field}`, val);
        if (next && next.trim()) {
          const trimmed = next.trim();
          optionsCache[field] = dedupe(current.map((v) => (v === val ? trimmed : v)));
          if (!removedOptions[field]) removedOptions[field] = [];
          if (!removedOptions[field].includes(val)) removedOptions[field].push(val);
          removedOptions[field] = removedOptions[field].filter((v) => v !== trimmed);
          renderOptionEditor(field);
          renderPainOptionButtons();
        }
      }
      persistOptionCache();
      const listContainer = document.getElementById(`${field}-options`);
      if (listContainer) listContainer.classList.add("hidden");
    }

    function dedupe(list) {
      return Array.from(new Set((list || []).filter(Boolean).map((v) => v.trim())));
    }

    function wireOptionEditors() {
      document.querySelectorAll("[data-edit]").forEach((btn) => {
        btn.addEventListener("click", () => {
          const field = btn.dataset.edit;
          if (!field) return;
          const editor = document.getElementById(`${field}-editor`);
          const listContainer = document.getElementById(`${field}-options`);
          if (!editor) return;
          const isHidden = editor.classList.contains("hidden");
          document.querySelectorAll(".chip-editor").forEach((ed) => ed.classList.add("hidden"));
          document.querySelectorAll(".chip-row").forEach((row) => row.classList.remove("hidden"));
          if (isHidden) {
            editor.classList.remove("hidden");
            if (listContainer) listContainer.classList.add("hidden");
            renderOptionEditor(field);
          }
        });
      });
    }

    function selectedOptions(containerId) {
      const el = document.getElementById(containerId);
      if (!el) return [];
      return Array.from(el.querySelectorAll(".chip-btn.active")).map((btn) => btn.dataset.value || "");
    }

    function normalizeParsed(parsed, kind) {
      if (!parsed?.headers || !Array.isArray(parsed.rows)) return parsed;
      const result = normalizeRows(parsed.headers, parsed.rows, kind);
      return { headers: result.headers, rows: result.rows };
    }

    function normalizeDataset(data, kind) {
      if (!data?.headers || !Array.isArray(data.rows)) return { data, changed: false };
      const normalized = normalizeRows(data.headers, data.rows, kind);
      return {
        data: { ...data, headers: normalized.headers, rows: normalized.rows },
        changed: normalized.changed,
      };
    }

    function entryDateFromRow(row, headers) {
      const dateKey = findHeader(headers, "date") || "date";
      const timeKey = findHeader(headers, "hour") || "hour";
      const dateVal = (row?.[dateKey] || "").trim();
      const timeVal = (row?.[timeKey] || "").trim() || "21:00";
      if (!dateVal) return null;
      const d = new Date(`${dateVal}T${timeVal}`);
      return d.toString() === "Invalid Date" ? null : d;
    }

    async function persistNormalized(kind, payload) {
      const cfg = datasets[kind];
      if (!cfg) return;
      try {
        const res = await apiFetch(`/api/files/${cfg.file}`, {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });
        if (res.status === 401) throw new Error("Please log in to save");
        if (!res.ok) throw new Error(`Server returned ${res.status}`);
      } catch (err) {
        console.warn("Failed to persist normalized data", err);
      }
    }

    async function saveDataset(kind, payload) {
      const normalized = normalizeRows(payload.headers || [], payload.rows || [], kind);
      const sorted = sortRowsByDateTime(normalized.rows, normalized.headers);
      const final = { headers: normalized.headers, rows: sorted, source: payload.source || "import", imported_at: new Date().toISOString() };
      dataStore[kind] = final;
      renderLog(kind);
      setStatus(kind, `Saved ${sorted.length} rows`, true, "logs");
      await persistNormalized(kind, final);
      if (kind === "pain") {
        buildOptionCacheFromStore();
        renderPainOptionButtons();
      }
      renderDashboard();
    }

    async function persist(kind, parsed, sourceName) {
      const cfg = datasets[kind];
      try {
        const normalizedIncoming = normalizeRows(parsed.headers, parsed.rows, kind);
        const existingNormalized = normalizeRows(
          dataStore[kind]?.headers || normalizedIncoming.headers,
          dataStore[kind]?.rows || [],
          kind
        );
        const mergedHeaders = Array.from(
          new Set([...(existingNormalized.headers || []), ...(normalizedIncoming.headers || [])])
        );
        const dateKey = findHeader(mergedHeaders, "date") || "date";
        const timeKey = findHeader(mergedHeaders, "hour") || "hour";
        const seen = new Set(
          existingNormalized.rows.map(r => `${r[dateKey] || ""}T${(r[timeKey] || "21:00").slice(0, 5)}`)
        );
        let added = 0;
        let skipped = 0;
        const mergedRows = [...existingNormalized.rows];

        normalizedIncoming.rows.forEach(r => {
          const stamp = `${(r[dateKey] || "").trim()}T${(r[timeKey] || "21:00").slice(0, 5)}`;
          if (!stamp.trim()) return;
          if (seen.has(stamp)) {
            skipped += 1;
          } else {
            seen.add(stamp);
            mergedRows.push(r);
            added += 1;
          }
        });

        const sortedRows = sortRowsByDateTime(mergedRows, mergedHeaders);
        const payload = {
          source: sourceName,
          imported_at: new Date().toISOString(),
          headers: mergedHeaders,
          rows: sortedRows,
        };
        const res = await apiFetch(`/api/files/${cfg.file}`, {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });
        if (res.status === 401) {
          throw new Error("Please log in to save");
        }
        if (!res.ok) {
          throw new Error(`Server returned ${res.status}`);
        }
        dataStore[kind] = payload;
        renderLog(kind);
        setStatus(kind, `Saved to ${cfg.file} (${mergedRows.length} total rows)`, true, "import");
        setStatus(kind, `Updated ${mergedRows.length} rows from ${sourceName}`, true, "logs");
        renderDashboard();
        return { added, skipped };
      } catch (err) {
        console.error(err);
        setStatus(kind, err.message || "Failed to save", false, "import");
        throw err;
      }
    }

    function wireEntryTabs() {
      const buttons = document.querySelectorAll(".entry-btn");
      const panels = document.querySelectorAll("[data-entry-panel]");
      const autotherapyTab = document.getElementById("autotherapy-tab");
      const setAutotherapyLabel = (key) => {
        if (!autotherapyTab) return;
        const arrow = key === "autotherapy" ? "‚ñº" : "‚óÄ";
        autotherapyTab.textContent = `Autotherapy ${arrow}`;
      };
      const setActive = (key) => {
        if (!key) return;
        buttons.forEach((btn) => btn.classList.toggle("active", btn.dataset.entry === key));
        panels.forEach((panel) => panel.classList.toggle("hidden", panel.dataset.entryPanel !== key));
        setAutotherapyLabel(key);
      };
      buttons.forEach((btn) => {
        btn.addEventListener("click", () => setActive(btn.dataset.entry));
      });
      if (buttons.length) {
        const current = document.querySelector(".entry-btn.active")?.dataset.entry || buttons[0].dataset.entry;
        setActive(current);
      }
      entryTabSetter = setActive;
    }

    function wirePainForm() {
      const form = document.getElementById("pain-form");
      const status = document.getElementById("pain-form-status");
      if (!form) return;

      const setStatus = (msg, ok = false) => {
        if (!status) return;
        status.innerHTML = msg ? `<span class="${ok ? "ok" : "err"}">${ok ? "Saved" : "Error"}:</span> ${escapeHtml(msg)}` : "";
      };

      const setDefaultDate = () => {
        const input = form.querySelector('input[name="pain-date"]');
        if (input && !input.value) {
          const now = new Date();
          const localIso = new Date(now.getTime() - now.getTimezoneOffset() * 60000).toISOString().slice(0, 16);
          input.value = localIso;
        }
      };

      setDefaultDate();
      renderPainOptionButtons();

      const cancelBtn = document.getElementById("pain-cancel-btn");
      if (cancelBtn) {
        cancelBtn.addEventListener("click", () => {
          resetEditState();
        });
      }

      form.addEventListener("submit", async (e) => {
        e.preventDefault();
        const data = new FormData(form);
        const toParts = (val) => {
          const fallback = new Date();
          const parsed = val ? new Date(val) : fallback;
          const good = parsed.toString() !== "Invalid Date" ? parsed : fallback;
          const iso = new Date(good.getTime() - good.getTimezoneOffset() * 60000).toISOString();
          return { date: iso.slice(0, 10), time: iso.slice(11, 16) };
        };
        const parts = toParts(data.get("pain-date"));
        const areas = selectedOptions("area-options").join(", ");
        const symptoms = selectedOptions("symptoms-options").join(", ");
        const activities = selectedOptions("activities-options").join(", ");
        const medicines = selectedOptions("medicines-options").join(", ");
        const other = selectedOptions("other-options").join(", ");
        const habits = selectedOptions("habits-options").join(", ");
        const row = {
          "date": parts.date,
          "hour": parts.time,
          "pain level": data.get("pain-level") || "",
          "fatigue level": data.get("fatigue-level") || "",
          "symptoms": symptoms,
          "area": areas,
          "activities": activities,
          "habits": habits,
          "coffee": data.get("coffee-count") || "",
          "other": other,
          "medicines": medicines,
          "note": data.get("pain-note") || "",
        };
        const parsed = { headers: REQUIRED.pain, rows: [row] };
        try {
          if (editingEntry.kind === "pain" && editingEntry.idx !== null) {
            // Update existing
            const rows = [...dataStore.pain.rows];
            rows[editingEntry.idx] = row;
            await saveRows("pain", rows);
            setStatus("Updated pain entry", true);
            resetEditState();
          } else {
            // Create new
            await persist("pain", parsed, "manual form");
            setStatus("Saved new pain entry", true);
            buildOptionCacheFromStore();
            renderPainOptionButtons();
            optionFields.forEach((field) => {
              const editor = document.getElementById(`${field}-editor`);
              if (editor && !editor.classList.contains("hidden")) renderOptionEditor(field);
            });
            form.reset();
            setDefaultDate();
          }
        } catch (err) {
          setStatus(err.message || "Failed to save pain entry", false);
        }
      });
    }

    function wireDropZones() {
      document.querySelectorAll('input[type="file"]').forEach(input => {
        input.addEventListener("change", (e) => {
          const kind = e.target.dataset.kind;
          const file = e.target.files?.[0];
          handleFile(kind, file);
        });


        const label = input.closest(".drop");
        label.addEventListener("dragover", (e) => { e.preventDefault(); label.classList.add("hover"); });
        label.addEventListener("dragleave", () => label.classList.remove("hover"));
        label.addEventListener("drop", (e) => {
          e.preventDefault();
          label.classList.remove("hover");
          const file = e.dataTransfer.files?.[0];
          handleFile(input.dataset.kind, file);
        });
      });
    }

    function wireBackup() {
      backupUI.importInput?.addEventListener("change", async (e) => {
        const file = e.target.files?.[0];
        if (!file) return;
        try {
          const text = await file.text();
          const parsed = JSON.parse(text);
          const toImport = ["diary", "pain"];
          for (const kind of toImport) {
            if (parsed[kind]?.headers && Array.isArray(parsed[kind].rows)) {
              await saveDataset(kind, parsed[kind]);
            }
          }
          setBackupStatus("Import completato", true);
        } catch (err) {
          setBackupStatus(err.message || "Import failed", false);
        } finally {
          e.target.value = "";
        }
      });

      backupUI.exportBtn?.addEventListener("click", async () => {
        try {
          await ensureLoaded("diary");
          await ensureLoaded("pain");
          const payload = {
            diary: dataStore.diary || { headers: REQUIRED.diary, rows: [] },
            pain: dataStore.pain || { headers: REQUIRED.pain, rows: [] },
          };
          const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = "myhealth-backup.json";
          a.click();
          URL.revokeObjectURL(url);
          setBackupStatus("Backup esportato", true);
        } catch (err) {
          setBackupStatus(err.message || "Export failed", false);
        }
      });

      backupUI.purgeBtn?.addEventListener("click", async () => {
        const ok = confirm("Are you sure you want to delete all diary and pain data?");
        if (!ok) return;
        try {
          const emptyDiary = { headers: REQUIRED.diary, rows: [], source: "purge" };
          const emptyPain = { headers: REQUIRED.pain, rows: [], source: "purge" };
          await saveDataset("diary", emptyDiary);
          await saveDataset("pain", emptyPain);
          setBackupStatus("Dati azzerati", true);
        } catch (err) {
          setBackupStatus(err.message || "Purge failed", false);
        }
      });

      backupUI.importXlsx?.addEventListener("change", async (e) => {
        const file = e.target.files?.[0];
        if (!file) return;
        try {
          const wb = await parseXlsx(file);
          const diarySheet = sheetToDataset(wb.Sheets["diary"]);
          const painSheet = sheetToDataset(wb.Sheets["pain"]);
          if (diarySheet) await saveDataset("diary", diarySheet);
          if (painSheet) await saveDataset("pain", painSheet);
          setBackupStatus("Import XLSX completato", true);
        } catch (err) {
          setBackupStatus(err.message || "Import XLSX failed", false);
          setBackupError(err?.stack || err?.message || String(err));
        } finally {
          e.target.value = "";
        }
      });

      backupUI.exportXlsx?.addEventListener("click", async () => {
        try {
          await ensureLoaded("diary");
          await ensureLoaded("pain");
          const wb = XLSX.utils.book_new();
          const diarySheet = datasetToSheet(dataStore.diary || { headers: REQUIRED.diary, rows: [] });
          const painSheet = datasetToSheet(dataStore.pain || { headers: REQUIRED.pain, rows: [] });
          XLSX.utils.book_append_sheet(wb, diarySheet, "diary");
          XLSX.utils.book_append_sheet(wb, painSheet, "pain");
          const wbout = XLSX.write(wb, { bookType: "xlsx", type: "array" });
          const blob = new Blob([wbout], { type: "application/octet-stream" });
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = "myhealth-data.xlsx";
          a.click();
          URL.revokeObjectURL(url);
          setBackupStatus("Export XLSX completato", true);
        } catch (err) {
          setBackupStatus(err.message || "Export XLSX failed", false);
          setBackupError(err?.stack || err?.message || String(err));
        }
      });
    }

    function wireNav() {
      const buttons = document.querySelectorAll(".nav-btn[data-target]");
      const sections = {
        dashboard: document.getElementById("dashboard-section"),
        newlog: document.getElementById("newlog-section"),
        import: document.getElementById("import-section"),
      };
      buttons.forEach(btn => {
        btn.addEventListener("click", () => {
          const target = btn.dataset.target;
          buttons.forEach(b => b.classList.toggle("active", b === btn));
          Object.entries(sections).forEach(([key, el]) => {
            if (el) {
              el.classList.toggle("hidden", key !== target);
            }
          });
          if (target === "newlog" && entryTabSetter) {
            const current = document.querySelector(".entry-btn.active")?.dataset.entry
              || document.querySelector(".entry-btn")?.dataset.entry;
            entryTabSetter(current);
          }
        });
      });
    }

    function getDateRange() {
      const fromInput = document.getElementById("filter-from");
      const toInput = document.getElementById("filter-to");
      const fromVal = fromInput?.value ? new Date(fromInput.value) : null;
      const toVal = toInput?.value ? new Date(toInput.value) : null;
      return {
        from: fromVal && !isNaN(fromVal) ? fromVal : null,
        to: toVal && !isNaN(toVal) ? toVal : null,
      };
    }

    function previousRange(range) {
      if (!range?.from) return null;
      const to = range.to && !isNaN(range.to) ? range.to : new Date();
      const duration = to.getTime() - range.from.getTime();
      if (duration <= 0) return null;
      const prevTo = new Date(range.from.getTime() - 24 * 60 * 60 * 1000);
      const prevFrom = new Date(prevTo.getTime() - duration);
      return { from: prevFrom, to: prevTo };
    }

    function renderDashboard() {
      closeEmojiPicker();
      const container = document.getElementById("dash-cards");
      const graphs = document.getElementById("dash-graphs");
      if (!container || !graphs) return;
      const range = getDateRange();
      const diary = applyDateFilter(dataStore.diary, range);
      const pain = applyDateFilter(dataStore.pain, range);
      const prevRange = previousRange(range);
      const diaryPrev = prevRange ? applyDateFilter(dataStore.diary, prevRange) : null;
      const painPrev = prevRange ? applyDateFilter(dataStore.pain, prevRange) : null;

      const diaryCount = diary?.rows?.length || 0;
      const painCount = pain?.rows?.length || 0;
      const diaryMoodAvg = avgField(diary, "mood level");
      const diaryDepAvg = avgField(diary, "depression");
      const diaryAnxAvg = avgField(diary, "anxiety");
      const painLevelAvg = avgField(pain, "pain level");
      const fatigueAvg = avgField(pain, "fatigue level");
      const diaryPrevCount = diaryPrev?.rows?.length ?? null;
      const painPrevCount = painPrev?.rows?.length ?? null;
      const diaryPrevMoodAvg = avgField(diaryPrev, "mood level");
      const diaryPrevDepAvg = avgField(diaryPrev, "depression");
      const diaryPrevAnxAvg = avgField(diaryPrev, "anxiety");
      const painPrevLevelAvg = avgField(painPrev, "pain level");
      const fatiguePrevAvg = avgField(painPrev, "fatigue level");

      const cards = [
        { label: "Journal entries", value: diaryCount, prev: diaryPrevCount },
        { label: "Pain entries", value: painCount, prev: painPrevCount },
        { label: "Mood avg", value: diaryMoodAvg ?? "‚Äì", prev: diaryPrevMoodAvg },
        { label: "Depression avg", value: diaryDepAvg ?? "‚Äì", prev: diaryPrevDepAvg },
        { label: "Anxiety avg", value: diaryAnxAvg ?? "‚Äì", prev: diaryPrevAnxAvg },
        { label: "Pain avg", value: painLevelAvg ?? "‚Äì", prev: painPrevLevelAvg },
        { label: "Fatigue avg", value: fatigueAvg ?? "‚Äì", prev: fatiguePrevAvg },
      ].map((c) => ({ ...c, emoji: cardEmojiMap[c.label] || "üìä" }));

      container.innerHTML = cards
        .map((c) => {
          const delta = calcDelta(c.value, c.prev, c.label);
          const deltaHtml = delta ? `<span class="delta ${delta.cls}">${escapeHtml(delta.text)}</span>` : "";
          return `
            <div class="dash-card">
              <div class="dash-emoji" data-label="${escapeHtml(c.label)}">${escapeHtml(c.emoji)}</div>
              <div class="dash-divider"></div>
              <div class="dash-meta">
                <div class="dash-label">${escapeHtml(c.label)}</div>
                <div class="dash-value">${escapeHtml(c.value)}${deltaHtml}</div>
              </div>
            </div>
          `;
        })
        .join("");

      const graphDefs = [
        { id: "graph-diary-mood", title: "Diary: Mood over time", yLabel: "Mood level", data: timeSeries(diary, "mood level") },
        { id: "graph-pain-level", title: "Pain: Pain level over time", yLabel: "Pain level", data: timeSeries(pain, "pain level") },
      ];

      graphs.innerHTML = graphDefs
        .map(
          (g) => `
            <div class="graph-card">
              <div class="graph-title">${escapeHtml(g.title)}</div>
              <canvas id="${g.id}"></canvas>
            </div>
          `
        )
        .join("");

      container.querySelectorAll(".dash-emoji").forEach((el) => {
        el.addEventListener("click", (e) => {
          e.stopPropagation();
          const label = el.getAttribute("data-label");
          if (label) openEmojiPicker(label, el);
        });
      });

      graphDefs.forEach((g, idx) => {
        const canvas = document.getElementById(g.id);
        drawLineChart(canvas, g.data, idx, { yLabel: g.yLabel });
      });
    }

    function avgField(store, field) {
      if (!store?.rows?.length) return null;
      const key = findHeader(store.headers, field) || field;
      let sum = 0;
      let count = 0;
      store.rows.forEach((row) => {
        const val = parseFloat(row[key]);
        if (!Number.isNaN(val)) {
          sum += val;
          count += 1;
        }
      });
      if (!count) return null;
      return parseFloat((sum / count).toFixed(2));
    }

    function calcDelta(current, previous, label = "") {
      const curNum = toNumber(current);
      const prevNum = toNumber(previous);
      if (curNum === null || prevNum === null || prevNum === 0) return null;
      const pct = ((curNum - prevNum) / prevNum) * 100;
      const lowerLabel = (label || "").toLowerCase();
      // Invert logic for negative things: Depression, Anxiety, Pain avg, Fatigue avg
      // Note: "Pain entries" is activity (good/neutral), so we specifically target "pain avg"
      const invert =
        lowerLabel.includes("depression") ||
        lowerLabel.includes("anxiety") ||
        lowerLabel.includes("pain avg") ||
        lowerLabel.includes("fatigue avg");

      const positive = invert ? pct < 0 : pct > 0;
      const negative = invert ? pct > 0 : pct < 0;
      return {
        text: `${pct > 0 ? "+" : ""}${pct.toFixed(0)}%`,
        cls: positive ? "positive" : negative ? "negative" : "neutral",
      };
    }

    function toNumber(val) {
      const n = Number(val);
      return Number.isFinite(n) ? n : null;
    }

    function timeSeries(store, field) {
      if (!store?.rows?.length) return [];
      const key = findHeader(store.headers, field) || field;
      return store.rows
        .map((row) => {
          const d = entryDateFromRow(row, store.headers);
          const v = parseFloat(row[key]);
          return { t: d, v };
        })
        .filter((p) => p.t && p.t.toString() !== "Invalid Date" && !Number.isNaN(p.v))
        .sort((a, b) => a.t - b.t);
    }

    const graphMeta = {};

    function drawLineChart(canvas, data, idx, opts = {}) {
      if (!canvas || !canvas.getContext) return;
      const ctx = canvas.getContext("2d");
      const width = (canvas.width = canvas.offsetWidth || 320);
      const height = (canvas.height = canvas.offsetHeight || 180);
      ctx.clearRect(0, 0, width, height);
      ctx.strokeStyle = ["#ff5e8a", "#ff8fb1", "#ffb3c9"][idx % 3];
      ctx.lineWidth = 2;
      ctx.fillStyle = "rgba(255,255,255,0.04)";
      ctx.fillRect(0, 0, width, height);
      if (!data.length) {
        ctx.fillStyle = "rgba(226,232,240,0.7)";
        ctx.fillText("No data yet", 12, 20);
        return;
      }
      const yBounds = getYBounds(opts.yLabel, data);
      const minY = yBounds.min;
      const maxY = yBounds.max;
      const minX = data[0].t.getTime();
      const maxX = data[data.length - 1].t.getTime();
      const startTs = minX;
      const pad = 28;
      ctx.beginPath();
      const points = [];
      data.forEach((pt, i) => {
        const x = scale(pt.t.getTime(), minX, maxX || minX + 1, pad, width - pad);
        const y = scale(pt.v, maxY === minY ? minY - 1 : minY, maxY === minY ? minY + 1 : maxY, height - pad, pad);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
        points.push({ x, y, ...pt });
      });
      ctx.stroke();
      ctx.fillStyle = ctx.strokeStyle;
      data.forEach((pt) => {
        const x = scale(pt.t.getTime(), minX, maxX || minX + 1, pad, width - pad);
        const y = scale(pt.v, maxY === minY ? minY - 1 : minY, maxY === minY ? minY + 1 : maxY, height - pad, pad);
        ctx.beginPath();
        ctx.arc(x, y, 3, 0, Math.PI * 2);
        ctx.fill();
      });

      // axis ticks
      drawAxes(ctx, width, height, pad, minX, maxX, minY, maxY, data, startTs);

      graphMeta[canvas.id] = { points, yLabel: opts.yLabel || "Value", startTime: startTs };
      canvas.onmousemove = (e) => handleHover(canvas, e);
      canvas.onmouseleave = () => hideTooltip();
    }

    function scale(val, min, max, outMin, outMax) {
      if (max === min) return (outMin + outMax) / 2;
      return outMin + ((val - min) / (max - min)) * (outMax - outMin);
    }

    function getYBounds(label, data) {
      const rawMin = Math.min(...data.map(d => d.v));
      const rawMax = Math.max(...data.map(d => d.v));
      const normLabel = (label || "").toLowerCase();
      const preset = ["pain", "fatigue", "mood", "depression", "anxiety"].some(k => normLabel.includes(k));
      let min = preset ? 0 : rawMin;
      let max = preset ? 10 : rawMax;
      if (!preset) {
        const pad = Math.max(1, (rawMax - rawMin) * 0.1);
        min = rawMin - pad;
        max = rawMax + pad;
      }
      if (min === max) {
        min -= 1;
        max += 1;
      }
      return { min, max };
    }

    function drawAxes(ctx, width, height, pad, minX, maxX, minY, maxY, data, startTs) {
      ctx.strokeStyle = "rgba(226,232,240,0.2)";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(pad, pad);
      ctx.lineTo(pad, height - pad);
      ctx.lineTo(width - pad, height - pad);
      ctx.stroke();

      ctx.fillStyle = "rgba(226,232,240,0.7)";
      ctx.font = "10px Manrope, sans-serif";
      ctx.textAlign = "right";
      const yTicks = Math.max(3, Math.min(6, Math.floor(height / 70)));
      for (let i = 0; i <= yTicks; i++) {
        const v = minY + ((maxY - minY) * i) / yTicks;
        const y = scale(v, minY, maxY, height - pad, pad);
        ctx.fillText(v.toFixed(0), pad - 6, y + 3);
        ctx.strokeStyle = "rgba(226,232,240,0.08)";
        ctx.beginPath();
        ctx.moveTo(pad + 2, y);
        ctx.lineTo(width - pad, y);
        ctx.stroke();
      }

      const xLabels = pickXLabels(data, startTs, maxX, width - pad * 2);
      ctx.textAlign = "center";
      xLabels.forEach((lbl) => {
        const x = scale(lbl.time, minX, maxX || minX + 1, pad, width - pad);
        ctx.fillText(lbl.text, x, height - pad + 12);
        ctx.strokeStyle = "rgba(226,232,240,0.08)";
        ctx.beginPath();
        ctx.moveTo(x, height - pad);
        ctx.lineTo(x, pad);
        ctx.stroke();
      });
    }

    function pickXLabels(data, startTs, endTs, usableWidth) {
      const labels = [];
      if (!data.length) return labels;
      const formatter = new Intl.DateTimeFormat(undefined, { month: "short", day: "numeric" });
      const maxSteps = Math.max(2, Math.min(6, Math.floor((usableWidth || 300) / 140)));
      const steps = Math.max(2, maxSteps);
      for (let i = 0; i <= steps; i++) {
        const frac = i / steps;
        const time = startTs + (endTs - startTs) * frac;
        labels.push({ time, text: formatter.format(new Date(time)) });
      }
      return labels;
    }

    function handleHover(canvas, evt) {
      const meta = graphMeta[canvas.id];
      if (!meta || !meta.points?.length) return hideTooltip();
      const rect = canvas.getBoundingClientRect();
      const x = evt.clientX - rect.left;
      const y = evt.clientY - rect.top;
      let closest = null;
      let minDist = Infinity;
      meta.points.forEach((p) => {
        const dx = p.x - x;
        const dy = p.y - y;
        const dist = Math.hypot(dx, dy);
        if (dist < minDist) {
          minDist = dist;
          closest = p;
        }
      });
      if (!closest || minDist > 12) return hideTooltip();
      const tooltip = getTooltip();
      const start = meta.startTime || (meta.points[0]?.t?.getTime?.() ?? 0);
      const dateText = new Intl.DateTimeFormat(undefined, { month: "short", day: "numeric" }).format(closest.t);
      tooltip.innerHTML = `<strong>${meta.yLabel}:</strong> ${closest.v}<br/><span style="color:${'var(--muted)'}">${dateText}</span>`;
      tooltip.style.left = `${evt.clientX + 12}px`;
      tooltip.style.top = `${evt.clientY + 12}px`;
      tooltip.style.opacity = "1";
    }

    function hideTooltip() {
      const t = document.getElementById("tooltip");
      if (t) t.style.opacity = "0";
    }

    function getTooltip() {
      let t = document.getElementById("tooltip");
      if (!t) {
        t = document.createElement("div");
        t.id = "tooltip";
        t.className = "tooltip";
        document.body.appendChild(t);
      }
      return t;
    }

    function setQuickActive(btn) {
      document.querySelectorAll(".quick-btn").forEach(b => b.classList.remove("active"));
      if (btn) btn.classList.add("active");
    }

    function clearQuickActive() {
      document.querySelectorAll(".quick-btn").forEach(b => b.classList.remove("active"));
      localStorage.removeItem("myhealth:lastRange");
    }

    function toCSV(headers, rows) {
      const esc = (val) => {
        const s = String(val ?? "");
        if (s.includes(",") || s.includes('"') || s.includes("\n")) {
          return `"${s.replace(/"/g, '""')}"`;
        }
        return s;
      };
      const head = headers.map(esc).join(",");
      const body = rows.map(r => headers.map(h => esc(r[h])).join(",")).join("\n");
      return `${head}\n${body}`;
    }

    function wireExport() {
      document.querySelectorAll("[data-export]").forEach(btn => {
        btn.addEventListener("click", () => {
          const kind = btn.dataset.export;
          const data = dataStore[kind];
          try {
            if (!data || !data.headers || !data.rows) {
              throw new Error("No data loaded yet. Import first.");
            }
            const blob = new Blob([toCSV(data.headers, data.rows)], { type: "text/csv;charset=utf-8" });
            const filename = `${kind}.csv`;
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
            showPopup(`Exported ${kind} as ${filename}`, true);
          } catch (err) {
            showPopup(err.message || "Export failed", false);
          }
        });
      });
    }

    function wirePurge() {
      document.querySelectorAll("[data-purge]").forEach(btn => {
        btn.addEventListener("click", async () => {
          const kind = btn.dataset.purge;
          try {
            const confirmFirst = confirm(`Are you sure you want to purge all ${kind} data?`);
            if (!confirmFirst) return;
            const confirmSecond = confirm("This will remove all rows. Confirm purge?");
            if (!confirmSecond) return;
            const payload = {
              source: "purge",
              imported_at: new Date().toISOString(),
              headers: dataStore[kind]?.headers || REQUIRED[kind] || [],
              rows: [],
            };
            const res = await apiFetch(`/api/files/${datasets[kind].file}`, {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(payload),
            });
            if (res.status === 401) throw new Error("Please log in to purge");
            if (!res.ok) throw new Error(`Server returned ${res.status}`);
            dataStore[kind] = payload;
            renderTable(kind, payload.headers, payload.rows);
            setStatus(kind, "Purged all rows", true, "import");
            setStatus(kind, "Purged all rows", true, "logs");
            showPopup(`Purged ${kind} data`, true);
            renderDashboard();
          } catch (err) {
            showPopup(err.message || "Purge failed", false);
            setStatus(kind, err.message || "Purge failed", false, "import");
          }
        });
      });
    }

    async function restoreSessionIfPossible() {
      // Try to load data with an existing session; if successful, show the app.
      const loadedDiary = await fetchExisting("diary", { silentAuthFail: true });
      const loadedPain = await fetchExisting("pain", { silentAuthFail: true });
      const hasData = loadedDiary || loadedPain;
      setAppVisible(hasData);
      setAuthVisibility(hasData);
      if (hasData) {
        renderDashboard();
      }
    }

    function applyDateFilter(store, range = getDateRange()) {
      if (!store?.rows?.length) return store;
      const fromVal = range?.from instanceof Date ? range.from : null;
      const toVal = range?.to instanceof Date ? range.to : null;
      if (!fromVal && !toVal) return store;
      const filteredRows = store.rows.filter((row) => {
        const d = entryDateFromRow(row, store.headers);
        if (!d) return false;
        if (fromVal && d < fromVal) return false;
        if (toVal && d > toVal) return false;
        return true;
      });
      return { ...store, rows: filteredRows };
    }

    buildOptionCacheFromStore();
    renderPainOptionButtons();
    wireAuthForm();
    wireEntryTabs();
    wireAutotherapyTabs();
    wirePainForm();
    wireJournalForm();
    wireOptionEditors();
    wireNav();
    wireBackup();
    ["filter-from", "filter-to"].forEach((id) => {
      const el = document.getElementById(id);
      if (el) {
        el.addEventListener("change", () => {
          clearQuickActive();
          renderDashboard();
        });
      }
    });
    function applyQuickRange(range, skipPersist = false) {
      const fromInput = document.getElementById("filter-from");
      const toInput = document.getElementById("filter-to");
      const today = new Date();
      const toStr = today.toISOString().slice(0, 10);
      if (range === "all") {
        if (fromInput) fromInput.value = "";
        if (toInput) toInput.value = "";
      } else {
        const days = parseInt(range, 10);
        const from = new Date(today.getTime() - days * 24 * 60 * 60 * 1000);
        const fromStr = from.toISOString().slice(0, 10);
        if (fromInput) fromInput.value = fromStr;
        if (toInput) toInput.value = toStr;
      }
      const btn = document.querySelector(`.quick-btn[data-range="${range}"]`);
      if (btn) setQuickActive(btn);
      if (!skipPersist) {
        localStorage.setItem("myhealth:lastRange", range);
      }
      renderDashboard();
    }

    document.querySelectorAll(".quick-btn").forEach((btn) => {
      btn.addEventListener("click", () => {
        const range = btn.dataset.range;
        applyQuickRange(range);
      });
    });
    setAuthVisibility(false);
    setAppVisible(false);
    resetAppState();
    restoreSessionIfPossible();
    const lastRange = localStorage.getItem("myhealth:lastRange") || "all";
    applyQuickRange(lastRange, true);
  </script>
</body>

</html>