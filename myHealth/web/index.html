<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>myHealth CSV Importer</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #000000;
      --panel: #0b0b0d;
      --card: #1f1f23;
      --card-strong: #26262b;
      --accent: #ff5e8a;
      --accent-2: #ff8fb1;
      --text: #f5f5f7;
      --muted: #a1a1ad;
      --border: #35353b;
      --danger: #ff5a7f;
      --shadow: 0 20px 55px rgba(0,0,0,0.5);
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Manrope", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background:
        radial-gradient(140% 120% at 20% 10%, rgba(255,94,138,0.14), rgba(0,0,0,0)),
        radial-gradient(120% 100% at 80% 5%, rgba(255,143,177,0.08), rgba(0,0,0,0)),
        var(--bg);
      background-repeat: no-repeat;
      background-size: cover;
      background-attachment: fixed;
      color: var(--text);
    }
    .shell {
      max-width: 1280px;
      margin: 0 auto;
      padding: 32px 22px 48px;
    }
    header { margin-bottom: 18px; }
    .title {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      font-size: 26px;
      font-weight: 700;
      letter-spacing: -0.02em;
    }
    .heart {
      width: 24px;
      height: 24px;
      border-radius: 8px;
      background: radial-gradient(circle at 30% 30%, #e44d75, #ff7fa6);
      display: grid;
      place-items: center;
      color: #fff;
      font-size: 14px;
      box-shadow: 0 4px 10px rgba(228,77,117,0.14);
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      gap: 18px;
      margin-bottom: 28px;
    }
    .card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 16px;
      padding: 18px;
      box-shadow: var(--shadow);
    }
    .card h2 {
      margin: 0 0 6px;
      font-size: 18px;
      letter-spacing: -0.01em;
    }
    .hint {
      color: var(--muted);
      font-size: 13px;
      margin-bottom: 12px;
    }
    .drop {
      border: 1px dashed var(--border);
      border-radius: 12px;
      padding: 18px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      background: var(--card);
      cursor: pointer;
      transition: border-color 0.2s ease, background 0.2s ease, box-shadow 0.2s ease;
      box-shadow: 0 8px 18px rgba(0,0,0,0.25);
    }
    .drop:hover {
      border-color: var(--accent);
      background: rgba(255,94,138,0.08);
    }
    .drop strong { display: block; }
    .drop input { display: none; }
    .status {
      font-size: 13px;
      color: var(--muted);
      margin-top: 10px;
      min-height: 18px;
    }
    .status .ok { color: var(--accent-2); font-weight: 700; }
    .status .err { color: var(--danger); font-weight: 700; }
    .table-wrap {
      margin-top: 12px;
      border: 1px solid var(--border);
      border-radius: 12px;
      overflow: hidden;
      width: 100%;
      max-width: 90vw;
      padding-right: 10px;
      box-sizing: border-box;
    }
    .table-scroll {
      width: 100%;
      max-width: 100%;
      max-height: 70vh;
      overflow: auto;
      padding-bottom: 6px;
      -webkit-overflow-scrolling: touch;
    }
    .table-wrap table {
      width: max-content;
      min-width: 1100px;
      table-layout: auto;
    }
    .table-wrap th,
    .table-wrap td {
      white-space: nowrap;
    }
<<<<<<< ours
    .table-wrap .actions-cell {
      position: sticky;
      right: 0;
      background: var(--card);
      z-index: 2;
      box-shadow: -1px 0 0 var(--border);
      min-width: 120px;
    }
    .table-wrap th.actions-cell {
      background: rgba(17,24,39,0.9);
      z-index: 3;
      box-shadow: -1px 0 0 var(--border), 0 1px 0 var(--border);
    }
=======
>>>>>>> theirs
    .table-wrap.limited {
      max-height: 440px;
    }
    @media (max-width: 640px) {
      .table-wrap {
        margin-left: -12px;
        margin-right: -12px;
        border-radius: 10px;
      }
      .table-wrap table {
        width: max-content;
        min-width: 760px;
      }
      .clip-cell {
        max-width: 180px;
        width: min(180px, 100%);
      }
    }
    /* Allow longer text columns to wrap */
    .table-wrap th:nth-child(n+6),
    .table-wrap td:nth-child(n+6) {
      white-space: normal;
    }
    .table-wrap.expanded {
      max-height: none;
    }
    .clip-cell {
      max-width: clamp(200px, 24vw, 260px);
      width: min(260px, 100%);
      white-space: normal;
      display: -webkit-box;
      -webkit-line-clamp: 3;
      -webkit-box-orient: vertical;
      overflow: hidden;
      text-overflow: ellipsis;
      word-break: break-word;
    }
    .log-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
    }
    .inline-input {
      width: 100%;
      padding: 10px 12px;
      border-radius: 6px;
      border: 1px solid var(--border);
      background: var(--card-strong);
      color: var(--text);
      box-sizing: border-box;
      height: 40px;
      line-height: 1.4;
    }
    .inline-input.long {
      min-width: 320px;
      max-width: 520px;
    }
    .inline-input.multiline {
      min-height: 64px;
      height: auto;
      line-height: 1.5;
      padding-top: 12px;
      padding-bottom: 12px;
      resize: vertical;
    }
    .sub-divider {
      display: flex;
      align-items: center;
      gap: 10px;
      border-bottom: 1px solid var(--border);
      padding-bottom: 10px;
      margin: 12px 0 8px;
    }
    .sub-divider .sub-label {
      color: var(--muted);
      font-size: 12px;
    }
    .autotherapy-subnav {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
      margin-top: 12px;
      padding: 10px 12px;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: var(--card-strong);
      box-shadow: 0 8px 18px rgba(0,0,0,0.25);
    }
    .autotherapy-subnav {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
      margin-top: 12px;
      padding: 10px 12px;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: var(--card-strong);
      box-shadow: 0 8px 18px rgba(0,0,0,0.25);
    }
    .autotherapy-subnav .sub-label {
      font-size: 12px;
      color: var(--muted);
      margin-right: 6px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
      min-width: 500px;
    }
    th, td {
      padding: 8px 10px;
      border-bottom: 1px solid var(--border);
      text-align: left;
      color: var(--text);
    }
    th {
      position: sticky;
      top: 0;
      background: rgba(17,24,39,0.9);
      z-index: 1;
      font-weight: 700;
      letter-spacing: 0.01em;
    }
    tbody tr:nth-child(odd) { background: rgba(255,255,255,0.02); }
    tbody tr:hover { background: rgba(255,94,138,0.08); }
    .badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 10px;
      background: rgba(34,197,94,0.15);
      color: var(--accent-2);
      font-weight: 600;
      font-size: 12px;
    }
    .rowcount { color: var(--muted); font-size: 12px; margin-left: 6px; }
    @media (max-width: 720px) {
      header { flex-direction: column; align-items: flex-start; }
      .grid { grid-template-columns: 1fr; }
    }
    nav {
      display: flex;
      gap: 10px;
      margin: 0;
      flex-wrap: wrap;
    }
    .top-nav {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
      margin-bottom: 18px;
    }
    .top-nav nav {
      flex: 1;
    }
    .logout-btn {
      margin-left: auto;
    }
    .entry-tabs {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin: 12px 0 4px;
    }
    .entry-panel {
      margin-top: 8px;
    }
    .nav-btn {
      padding: 10px 14px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: var(--card);
      color: var(--text);
      font-weight: 700;
      cursor: pointer;
      transition: all 0.2s ease;
      letter-spacing: 0.01em;
    }
    .nav-btn.danger {
      border-color: rgba(244,63,94,0.5);
      color: var(--danger);
      background: rgba(244,63,94,0.08);
    }
    .nav-btn.active {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px rgba(255,94,138,0.3), var(--shadow);
      color: var(--accent);
    }
    .auth-card {
      margin: 12px 0 18px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .auth-row {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
    }
    .auth-row input {
      background: var(--card-strong);
      border: 1px solid var(--border);
      border-radius: 10px;
      color: var(--text);
      padding: 10px;
      font-size: 14px;
      outline: none;
      min-width: 220px;
      flex: 1;
    }
    .auth-row input:focus {
      border-color: var(--accent);
      background: rgba(255,94,138,0.08);
    }
    .pill {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 10px 12px;
      border-radius: 12px;
      background: rgba(255,94,138,0.08);
      border: 1px solid rgba(255,94,138,0.24);
      color: var(--text);
      font-weight: 700;
      letter-spacing: 0.01em;
    }
    .form-grid {
      display: block;
      column-width: 220px;
      column-gap: 12px;
      column-fill: balance;
      margin-top: 10px;
    }
    .form-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding: 12px;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: var(--card);
      box-shadow: 0 8px 18px rgba(0,0,0,0.25);
      height: auto;
      break-inside: avoid;
      width: 100%;
      box-sizing: border-box;
      margin: 0 0 10px 0;
    }
    #logs-section .grid {
      grid-template-columns: 1fr;
    }
    .form-group label {
      font-size: 12px;
      color: var(--muted);
      letter-spacing: 0.01em;
    }
    .form-group input,
    .form-group select,
    .form-group textarea {
      background: var(--card-strong);
      border: 1px solid var(--border);
      border-radius: 10px;
      color: var(--text);
      padding: 10px;
      font-size: 14px;
      outline: none;
      transition: border-color 0.2s ease, background 0.2s ease;
    }
    .form-group input:focus,
    .form-group select:focus,
    .form-group textarea:focus {
      border-color: var(--accent);
      background: rgba(255,94,138,0.08);
    }
    .form-group small {
      color: var(--muted);
      font-size: 12px;
    }
    .form-group textarea {
      resize: vertical;
      min-height: 72px;
    }
    .form-actions {
      margin-top: 14px;
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }
    .btn-primary {
      background: linear-gradient(135deg, var(--accent), var(--accent-2));
      color: #0b0b0d;
      border: none;
      padding: 10px 16px;
      border-radius: 12px;
      font-weight: 800;
      cursor: pointer;
      box-shadow: 0 6px 12px rgba(255,94,138,0.16);
      letter-spacing: 0.01em;
    }
    .btn-primary.btn-plain {
      box-shadow: none;
      background: rgba(255,94,138,0.18);
      color: #fff;
      border: 1px solid rgba(255,94,138,0.35);
    }
    .btn-muted {
      background: var(--card-strong);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 10px 14px;
      border-radius: 10px;
      font-weight: 700;
      cursor: pointer;
    }
    .tile-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 12px;
      margin-top: 10px;
    }
    .chip-row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    .chip-btn {
      padding: 8px 12px;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: var(--card-strong);
      color: var(--text);
      cursor: pointer;
      font-weight: 700;
      transition: all 0.2s ease;
      font-size: 13px;
      box-shadow: none;
    }
    .chip-btn.active {
      background: rgba(255,94,138,0.06);
      border-color: rgba(255,94,138,0.25);
      color: #f1c8d7;
      box-shadow: none;
    }
    .tile {
      padding: 12px;
      border-radius: 12px;
      background: var(--card-strong);
      border: 1px solid var(--border);
      box-shadow: 0 10px 25px rgba(0,0,0,0.35);
    }
    .tile strong {
      display: block;
      margin-bottom: 4px;
    }
    .tile p {
      margin: 0;
      color: var(--muted);
      font-size: 13px;
      line-height: 1.4;
    }
    .chip-edit {
      margin-left: 8px;
      padding: 4px 8px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: var(--card-strong);
      color: var(--muted);
      font-size: 12px;
      cursor: pointer;
    }
    .chip-editor {
      margin-top: 8px;
      border: 1px dashed var(--border);
      padding: 10px;
      border-radius: 10px;
      background: rgba(255,255,255,0.02);
    }
    .chip-editor-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      padding: 6px 0;
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }
    .chip-editor-row:last-child { border-bottom: none; }
    .chip-editor-actions {
      display: flex;
      gap: 6px;
    }
    .chip-editor-actions button,
    .chip-editor-add button {
      padding: 6px 10px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: var(--card);
      color: var(--text);
      cursor: pointer;
      font-size: 12px;
    }
    .chip-editor-add {
      display: flex;
      gap: 8px;
      margin-top: 8px;
      align-items: center;
      width: 100%;
    }
    .chip-editor-add input {
      flex: 1;
      min-width: 0;
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: var(--card-strong);
      color: var(--text);
      box-sizing: border-box;
    }
    .chip-editor-add button { flex-shrink: 0; }
    .hidden { display: none; }
    .toast {
      position: fixed;
      right: 18px;
      bottom: 18px;
      min-width: 260px;
      max-width: 360px;
      padding: 14px 16px;
      border-radius: 12px;
      background: #0b1220;
      border: 1px solid var(--border);
      color: var(--text);
      box-shadow: var(--shadow);
      opacity: 0;
      transform: translateY(12px);
      transition: opacity 0.2s ease, transform 0.2s ease;
      z-index: 999;
    }
    .toast.show {
      opacity: 1;
      transform: translateY(0);
    }
    .toast.success { border-color: rgba(34,197,94,0.5); }
    .toast.error { border-color: rgba(244,63,94,0.5); }
    .dash-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 12px;
      margin-top: 12px;
    }
    .dash-card {
      padding: 12px;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: var(--card-strong);
      box-shadow: 0 10px 25px rgba(0,0,0,0.35);
    }
    .dash-label { color: var(--muted); font-size: 12px; }
    .dash-value { font-size: 18px; font-weight: 700; display: flex; align-items: baseline; gap: 6px; }
    .delta { font-size: 12px; }
    .delta.positive { color: #4ade80; }
    .delta.negative { color: #f87171; }
    .delta.neutral { color: var(--muted); }
    .graph-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(420px, 1fr));
      gap: 14px;
      margin-top: 16px;
    }
    .graph-card {
      background: var(--card);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 12px;
      box-shadow: 0 12px 28px rgba(0,0,0,0.4);
    }
    .graph-title {
      margin: 0 0 8px;
      font-size: 14px;
      color: var(--muted);
      display: flex;
      align-items: center;
      gap: 8px;
    }
    canvas { width: 100%; height: 160px; }
    .filters {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin: 10px 0;
      align-items: center;
    }
    .filters label {
      color: var(--muted);
      font-size: 12px;
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 6px;
      margin: 0;
    }
    .filters input {
      background: var(--card);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 8px 10px;
      border-radius: 8px;
    }
    .filters .divider {
      align-self: center;
      width: 1px;
      height: 28px;
      background: var(--border);
      margin: 0 6px;
    }
    .quick-filters {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }
    .quick-btn {
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: var(--card);
      color: var(--text);
      font-size: 12px;
      cursor: pointer;
      transition: border-color 0.2s ease, background 0.2s ease;
    }
    .quick-btn:hover {
      border-color: var(--accent);
      background: rgba(255,94,138,0.1);
    }
    .quick-btn.active {
      border-color: var(--accent);
      background: rgba(255,94,138,0.2);
      color: var(--text);
    }
    .tooltip {
      position: fixed;
      pointer-events: none;
      background: #0b1220;
      border: 1px solid var(--border);
      color: var(--text);
      padding: 8px 10px;
      border-radius: 8px;
      font-size: 12px;
      box-shadow: var(--shadow);
      opacity: 0;
      transition: opacity 0.1s ease;
      z-index: 1000;
    }
  </style>
</head>
<body>
  <div class="shell">
    <header>
      <div class="title">
        <span class="heart">❤</span>
        <span>myHealth</span>
      </div>
    </header>

    <div class="card auth-card">
      <div class="auth-row">
        <input type="email" id="auth-email" placeholder="Email" autocomplete="username" />
        <input type="password" id="auth-pass" placeholder="Password" autocomplete="current-password" />
        <button class="btn-primary" id="auth-login" type="button">Log in</button>
      </div>
      <div class="status" id="auth-status"></div>
    </div>

    <div id="app-main" class="hidden">
      <div class="top-nav">
        <nav>
          <button class="nav-btn active" data-target="dashboard">Dashboard</button>
          <button class="nav-btn" data-target="newlog">New Entry</button>
          <button class="nav-btn" data-target="logs">Logs</button>
          <button class="nav-btn" data-target="import">Import / Export</button>
        </nav>
        <button class="nav-btn danger logout-btn hidden" id="auth-logout" type="button">Log out</button>
      </div>

      <section id="dashboard-section">
        <div class="card" id="dashboard-stats">
          <h2>Dashboard</h2>
          <div class="hint">Overview of diary and pain logs.</div>
          <div class="filters">
            <label>From
              <input type="date" id="filter-from" />
            </label>
            <label>To
              <input type="date" id="filter-to" />
            </label>
            <div class="divider"></div>
            <div class="quick-filters">
              <button class="quick-btn" data-range="7">1 week</button>
              <button class="quick-btn" data-range="30">1 month</button>
              <button class="quick-btn" data-range="90">3 months</button>
              <button class="quick-btn" data-range="180">6 months</button>
              <button class="quick-btn" data-range="365">1 year</button>
              <button class="quick-btn" data-range="1095">3 years</button>
              <button class="quick-btn" data-range="all">Since start</button>
            </div>
          </div>
          <div class="dash-grid" id="dash-cards"></div>
        </div>
        <div class="graph-grid" id="dash-graphs"></div>
      </section>

      <section id="newlog-section" class="hidden">
        <div class="card">
          <h2>New Entry</h2>
          <div class="hint">Capture a quick log without waiting for a CSV import.</div>
          <div class="entry-tabs" role="tablist" aria-label="New entry categories">
            <button class="nav-btn entry-btn active" data-entry="pain" type="button">Physical pain</button>
          <button class="nav-btn entry-btn" id="autotherapy-tab" data-entry="autotherapy" type="button">Autotherapy ◀</button>
          </div>

          <div class="entry-panel" data-entry-panel="pain">
            <form id="pain-form">
              <div class="form-grid">
                <div class="form-group">
                  <label for="pain-date">Entry date/time</label>
                  <input id="pain-date" name="pain-date" type="datetime-local" />
                  <small>Stored as separate date + time columns; defaults to now if left empty.</small>
                </div>
                <div class="form-group">
                  <label for="pain-level">Pain level (1-9)</label>
                  <input id="pain-level" name="pain-level" type="number" min="1" max="9" step="1" placeholder="e.g. 6" />
                </div>
                <div class="form-group">
                  <label for="fatigue-level">Fatigue level (1-9)</label>
                  <input id="fatigue-level" name="fatigue-level" type="number" min="1" max="9" step="1" placeholder="e.g. 4" />
                </div>
                <div class="form-group">
                  <label>Area <button type="button" class="chip-edit" data-edit="area">Edit</button></label>
                  <div id="area-options" class="chip-row" data-field="area"></div>
                  <div id="area-editor" class="chip-editor hidden" data-field="area"></div>
                </div>
                <div class="form-group">
                  <label>Symptoms <button type="button" class="chip-edit" data-edit="symptoms">Edit</button></label>
                  <div id="symptoms-options" class="chip-row" data-field="symptoms"></div>
                  <div id="symptoms-editor" class="chip-editor hidden" data-field="symptoms"></div>
                </div>
                <div class="form-group">
                  <label>Activities <button type="button" class="chip-edit" data-edit="activities">Edit</button></label>
                  <div id="activities-options" class="chip-row" data-field="activities"></div>
                  <div id="activities-editor" class="chip-editor hidden" data-field="activities"></div>
                </div>
                <div class="form-group">
                  <label>Medicines <button type="button" class="chip-edit" data-edit="medicines">Edit</button></label>
                  <div id="medicines-options" class="chip-row" data-field="medicines" data-preselect="all"></div>
                  <div id="medicines-editor" class="chip-editor hidden" data-field="medicines"></div>
                </div>
                <div class="form-group">
                  <label for="pain-note">Notes</label>
                  <textarea id="pain-note" name="pain-note" placeholder="Anything else worth tracking?"></textarea>
                </div>
                <div class="form-group">
                  <label>Habits <button type="button" class="chip-edit" data-edit="habits">Edit</button></label>
                  <div id="habits-options" class="chip-row" data-field="habits"></div>
                  <div id="habits-editor" class="chip-editor hidden" data-field="habits"></div>
                </div>
                <div class="form-group">
                  <label for="coffee-count">Coffee (cups)</label>
                  <input id="coffee-count" name="coffee-count" type="number" min="0" max="9" step="1" placeholder="e.g. 1" />
                </div>
                <div class="form-group">
                  <label>Other <button type="button" class="chip-edit" data-edit="other">Edit</button></label>
                  <div id="other-options" class="chip-row" data-field="other"></div>
                  <div id="other-editor" class="chip-editor hidden" data-field="other"></div>
                </div>
              </div>
              <div class="form-actions">
                <button class="btn-primary btn-plain" type="submit">Save new entry</button>
                <div id="pain-form-status" class="status"></div>
              </div>
            </form>
          </div>

          <div class="entry-panel hidden" data-entry-panel="autotherapy">
            <div id="autotherapy-stack">
              <div class="entry-tabs autotherapy-subnav" role="tablist" aria-label="Autotherapy entries">
                <button class="nav-btn entry-btn secondary" data-autotherapy="journal" type="button">Journal</button>
                <button class="nav-btn entry-btn secondary" data-autotherapy="cbt" type="button">CBT thought response</button>
                <button class="nav-btn entry-btn secondary" data-autotherapy="dbt" type="button">DBT distress tolerance</button>
              </div>
              <div class="entry-panel hidden" data-autotherapy-panel="journal">
                <form id="journal-form">
                  <div class="form-grid">
                    <div class="form-group">
                      <label for="journal-date">Entry date/time</label>
                      <input id="journal-date" name="journal-date" type="datetime-local" />
                      <small>Stored as separate date + time columns; defaults to now if left empty.</small>
                    </div>
                    <div class="form-group">
                      <label for="journal-mood">Mood level (1-9)</label>
                      <input id="journal-mood" name="journal-mood" type="number" min="1" max="9" step="1" placeholder="e.g. 6" />
                    </div>
                    <div class="form-group">
                      <label for="journal-depression">Depression (1-9)</label>
                      <input id="journal-depression" name="journal-depression" type="number" min="1" max="9" step="1" placeholder="e.g. 4" />
                    </div>
                    <div class="form-group">
                      <label for="journal-anxiety">Anxiety (1-9)</label>
                      <input id="journal-anxiety" name="journal-anxiety" type="number" min="1" max="9" step="1" placeholder="e.g. 5" />
                    </div>
                    <div class="form-group" style="grid-column: 1 / -1;">
                      <label for="journal-description">description</label>
                      <textarea id="journal-description" name="journal-description" placeholder="cosa hai fatto oggi?"></textarea>
                    </div>
                    <div class="form-group" style="grid-column: 1 / -1;">
                      <label for="journal-gratitude">gratitude</label>
                      <textarea id="journal-gratitude" name="journal-gratitude" placeholder="per cosa sei grato?"></textarea>
                    </div>
                    <div class="form-group" style="grid-column: 1 / -1;">
                      <label for="journal-reflection">reflection</label>
                      <textarea id="journal-reflection" name="journal-reflection" placeholder="vuoi riflettere su qualcosa?"></textarea>
                    </div>
                  </div>
                  <div class="form-actions">
                    <button class="btn-primary btn-plain" type="submit">Save journal entry</button>
                    <div id="journal-form-status" class="status"></div>
                  </div>
                </form>
              </div>
              <div class="entry-panel hidden" data-autotherapy-panel="cbt">
                <div class="hint">CBT thought response coming soon.</div>
              </div>
              <div class="entry-panel hidden" data-autotherapy-panel="dbt">
                <div class="hint">DBT distress tolerance coming soon.</div>
              </div>
            </div>
          </div>
        </div>
      </section>

      <section id="logs-section" class="hidden">
        <div class="grid">
          <div class="card">
            <div class="log-header">
              <h2>Journal log</h2>
              <button class="nav-btn small" data-toggle-log="diary">Expand ◀</button>
            </div>
            <div class="table-wrap" id="diary-table"></div>
          </div>
          <div class="card">
            <div class="log-header">
              <h2>Pain log</h2>
              <button class="nav-btn small" data-toggle-log="pain">Expand ◀</button>
            </div>
            <div class="table-wrap" id="pain-table"></div>
          </div>
        </div>
      </section>

      <section id="import-section" class="hidden">
        <div class="grid">
          <div class="card">
            <h2></h2>
            <label class="drop">
              <div>
                <strong>Select or drop Diary CSV</strong>
              </div>
              <input type="file" accept=".csv,text/csv" data-kind="diary" />
              <span class="badge">Import</span>
            </label>
            <div class="status" id="diary-status-import"></div>
            <div style="margin-top:10px; display:flex; gap:10px; flex-wrap:wrap;">
              <button class="nav-btn" data-export="diary" data-type="csv">Export Diary CSV</button>
              <button class="nav-btn danger" data-purge="diary">Purge Diary Data</button>
            </div>
          </div>
          <div class="card">
            <h2></h2>
            <label class="drop">
              <div>
                <strong>Select or drop Pain CSV</strong>
              </div>
              <input type="file" accept=".csv,text/csv" data-kind="pain" />
              <span class="badge">Import</span>
            </label>
            <div class="status" id="pain-status-import"></div>
            <div style="margin-top:10px; display:flex; gap:10px; flex-wrap:wrap;">
              <button class="nav-btn" data-export="pain" data-type="csv">Export Pain CSV</button>
              <button class="nav-btn danger" data-purge="pain">Purge Pain Data</button>
            </div>
          </div>
        </div>
      </section>
    </div>
  </div>

  <script>
    const datasets = {
      diary: {
        file: "diary.json",
        logsTable: document.getElementById("diary-table"),
        statusLog: document.getElementById("diary-status-log"),
        statusImport: document.getElementById("diary-status-import"),
      },
      pain: {
        file: "pain.json",
        logsTable: document.getElementById("pain-table"),
        statusLog: document.getElementById("pain-status-log"),
        statusImport: document.getElementById("pain-status-import"),
      },
    };
    const dataStore = { diary: null, pain: null };
    const authUI = {
      email: document.getElementById("auth-email"),
      pass: document.getElementById("auth-pass"),
      status: document.getElementById("auth-status"),
      loginBtn: document.getElementById("auth-login"),
      logoutBtn: document.getElementById("auth-logout"),
    };
    const appMain = document.getElementById("app-main");
    let isAuthed = false;
    function apiFetch(url, options = {}) {
      const opts = { credentials: "include", ...options };
      opts.headers = { ...(options.headers || {}) };
      let finalUrl = url;
      if (url.startsWith("/")) {
        const pathBase = (window.location.pathname || "").replace(/\/[^/]*$/, "");
        const scopedBase = pathBase === "/" ? "" : pathBase;
        finalUrl = `${scopedBase}${url}`;
      }
      return fetch(finalUrl, opts);
    }
    function setAuthStatus(message, ok = false) {
      if (!authUI.status) return;
      authUI.status.innerHTML = message
        ? `<span class="${ok ? "ok" : "err"}">${ok ? "OK" : "Error"}:</span> ${escapeHtml(message)}`
        : "";
    }
    function setAuthVisibility(authed) {
      isAuthed = authed;
      const toHide = [authUI.email, authUI.pass, authUI.loginBtn, authUI.status];
      toHide.forEach((el) => el?.classList.toggle("hidden", authed));
      authUI.logoutBtn?.classList.toggle("hidden", !authed);
      const authCard = document.querySelector(".auth-card");
      authCard?.classList.toggle("hidden", authed);
      if (!authed) {
        setAuthStatus("");
      }
    }
    function setAppVisible(isAuthed) {
      if (appMain) appMain.classList.toggle("hidden", !isAuthed);
    }
    function resetAppState() {
      dataStore.diary = null;
      dataStore.pain = null;
      ["diary", "pain"].forEach((kind) => {
        const table = datasets[kind]?.logsTable;
        if (table) table.innerHTML = "";
        setStatus(kind, "", true, "logs");
        setStatus(kind, "", true, "import");
      });
      const dashCards = document.getElementById("dash-cards");
      const dashGraphs = document.getElementById("dash-graphs");
      if (dashCards) dashCards.innerHTML = "";
      if (dashGraphs) dashGraphs.innerHTML = "";
    }
    const REQUIRED = {
      diary: ["date", "hour", "mood level", "depression", "anxiety", "description", "gratitude", "reflection"],
      pain: [
        "date",
        "hour",
        "pain level",
        "fatigue level",
        "symptoms",
        "area",
        "activities",
        "habits",
        "coffee",
        "other",
        "medicines",
        "note",
      ],
    };
    const ALIASES = {
      diary: {
        "date": ["date", "file name"],
        "hour": ["hour", "time"],
      },
      pain: {
        "date": ["date", "file name"],
        "hour": ["hour", "time"],
        "pain level": ["pain level", "pain"],
        "fatigue level": ["fatigue level", "fatigue"],
        "habits": ["habits", "good sleep", "healthy food", "sleep"],
        "other": ["other", ">6h day byte", ">1h masturbation", "<1h masturbation", "cum"],
        "coffee": ["coffee"],
        "medicines": ["medicines"],
      },
    };
    const LONG_TEXT_FIELDS = [
      "description",
      "gratitude",
      "reflection",
      "note",
      "medicines",
      "symptoms",
      "activities",
      "area",
      "habits",
      "other",
    ];
    let entryTabSetter = null;
    const optionFields = ["area", "symptoms", "activities", "medicines", "habits", "other"];
    const OPTION_CACHE_KEY = "myhealth:painOptions:v2";
    const optionsCache = {
      area: [],
      symptoms: [],
      activities: [],
      medicines: [],
      habits: [],
      other: [],
    };
    const removedOptions = {
      area: [],
      symptoms: [],
      activities: [],
      medicines: [],
      habits: [],
      other: [],
    };

    function loadSavedOptionCache() {
      try {
        const raw = localStorage.getItem(OPTION_CACHE_KEY);
        if (!raw) {
          return { options: {}, removed: {} };
        }
        const parsed = JSON.parse(raw);
        if (!parsed || typeof parsed !== "object") {
          return { options: {}, removed: {} };
        }
        return {
          options: parsed.options || {},
          removed: parsed.removed || {},
        };
      } catch (err) {
        return { options: {}, removed: {} };
      }
    }

    function persistOptionCache() {
      try {
        localStorage.setItem(
          OPTION_CACHE_KEY,
          JSON.stringify({ options: optionsCache, removed: removedOptions })
        );
      } catch (err) {
        // best effort; ignore
      }
    }

    function wireAuthForm() {
      if (authUI.loginBtn) {
        authUI.loginBtn.addEventListener("click", () => doLogin());
      }
      if (authUI.logoutBtn) {
        authUI.logoutBtn.addEventListener("click", () => doLogout());
      }
    }

    async function doLogin() {
      const email = authUI.email?.value?.trim();
      const password = authUI.pass?.value || "";
      if (!email || !password) {
        setAuthStatus("Email and password required");
        return;
      }
      try {
        const res = await apiFetch("/api/files/login", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ email, password }),
        });
        const data = await res.json();
        if (!res.ok) {
          throw new Error(data?.error || "Login failed");
        }
        setAuthStatus(`Logged in as ${data.email || email}`, true);
        if (authUI.pass) authUI.pass.value = "";
        setAuthVisibility(true);
        setAppVisible(true);
        await fetchExisting("diary");
        await fetchExisting("pain");
        renderDashboard();
      } catch (err) {
        setAuthStatus(err.message || "Login failed");
      }
    }

    async function doLogout() {
      try {
        await apiFetch("/api/files/logout", { method: "POST" });
        setAuthStatus("Logged out", true);
        resetAppState();
        setAppVisible(false);
        setAuthVisibility(false);
      } catch (err) {
        setAuthStatus(err.message || "Logout failed");
      }
    }

    function buildOptionCacheFromStore() {
      const saved = loadSavedOptionCache();
      optionFields.forEach((field) => {
        const derived = collectOptions(field);
        const stored = Array.isArray(saved.options?.[field]) ? saved.options[field] : [];
        const removed = new Set(Array.isArray(saved.removed?.[field]) ? saved.removed[field] : []);
        const merged = dedupe([
          ...stored,
          ...(derived || []).filter((v) => !removed.has(v)),
        ]);
        optionsCache[field] = merged;
        removedOptions[field] = Array.from(removed);
      });
      persistOptionCache();
    }

    function wireJournalForm() {
      const form = document.getElementById("journal-form");
      const status = document.getElementById("journal-form-status");
      if (!form) return;
      const setStatusMsg = (msg, ok = false) => {
        if (!status) return;
        status.innerHTML = msg ? `<span class="${ok ? "ok" : "err"}">${ok ? "Saved" : "Error"}:</span> ${escapeHtml(msg)}` : "";
      };
      const setDefaultDate = () => {
        const input = form.querySelector('input[name="journal-date"]');
        if (input) {
          const now = new Date();
          const localIso = new Date(now.getTime() - now.getTimezoneOffset() * 60000).toISOString().slice(0, 16);
          input.value = localIso;
        }
      };
      setDefaultDate();
      form.addEventListener("submit", async (e) => {
        e.preventDefault();
        const data = new FormData(form);
        const toParts = (val) => {
          const fallback = new Date();
          const parsed = val ? new Date(val) : fallback;
          const good = parsed.toString() !== "Invalid Date" ? parsed : fallback;
          const iso = new Date(good.getTime() - good.getTimezoneOffset() * 60000).toISOString();
          return { date: iso.slice(0, 10), time: iso.slice(11, 16) };
        };
        const parts = toParts(data.get("journal-date"));
        const row = {
          "date": parts.date,
          "hour": parts.time,
          "mood level": data.get("journal-mood") || "",
          "depression": data.get("journal-depression") || "",
          "anxiety": data.get("journal-anxiety") || "",
          "description": data.get("journal-description") || "",
          "gratitude": data.get("journal-gratitude") || "",
          "reflection": data.get("journal-reflection") || "",
        };
        const parsed = { headers: REQUIRED.diary, rows: [row] };
        try {
          await persist("diary", parsed, "journal form");
          setStatusMsg("Saved journal entry", true);
          form.reset();
          setDefaultDate();
        } catch (err) {
          setStatusMsg(err.message || "Failed to save journal entry", false);
        }
      });
    }

    async function fetchExisting(kind, opts = {}) {
      const { silentAuthFail = false } = opts;
      const cfg = datasets[kind];
      try {
        const res = await apiFetch(`/api/files/${cfg.file}`);
        if (res.status === 401) {
          if (!silentAuthFail) setAuthStatus("Please log in to load data");
          return false;
        }
        if (!res.ok) return false;
        const data = await res.json();
        if (data && data.rows && data.headers) {
        const normalized = normalizeDataset(data, kind);
          const sortedRows = sortRowsByDateTime(normalized.data.rows, normalized.data.headers);
          const updated = { ...normalized.data, rows: sortedRows };
          dataStore[kind] = updated;
          renderLog(kind);
          setStatus(kind, `Loaded ${updated.rows.length} rows from ${cfg.file}`, true, "logs");
          if (normalized.changed) {
            await persistNormalized(kind, updated);
          }
          if (kind === "pain") {
            buildOptionCacheFromStore();
            renderPainOptionButtons();
          }
          renderDashboard();
          return true;
        }
      } catch (err) {
        console.warn("Load error", err);
      }
      return false;
    }

    function setStatus(kind, message, ok = false, target = "logs") {
      const el = target === "import" ? datasets[kind].statusImport : datasets[kind].statusLog;
      if (!el) return;
      el.innerHTML = message ? `<span class="${ok ? "ok" : "err"}">${ok ? "OK" : "Error"}:</span> ${message}` : "";
    }

    function showPopup(message, ok = true) {
      let toast = document.getElementById("toast");
      if (!toast) {
        toast = document.createElement("div");
        toast.id = "toast";
        toast.className = "toast";
        document.body.appendChild(toast);
      }
      toast.className = `toast ${ok ? "success" : "error"}`;
      toast.textContent = message;
      requestAnimationFrame(() => toast.classList.add("show"));
      setTimeout(() => toast.classList.remove("show"), 2800);
    }

    function sortRowsByDateTime(rows, headers) {
      const dKey = findHeader(headers, "date") || "date";
      const tKey = findHeader(headers, "hour") || "hour";
      return [...rows].sort((a, b) => {
        const aDate = new Date(`${a?.[dKey] || ""}T${(a?.[tKey] || "00:00").slice(0, 5)}`);
        const bDate = new Date(`${b?.[dKey] || ""}T${(b?.[tKey] || "00:00").slice(0, 5)}`);
        const aTs = aDate.toString() === "Invalid Date" ? 0 : aDate.getTime();
        const bTs = bDate.toString() === "Invalid Date" ? 0 : bDate.getTime();
        return bTs - aTs;
      });
    }

    function sortRowsWithIndex(rows, headers) {
      const dKey = findHeader(headers, "date") || "date";
      const tKey = findHeader(headers, "hour") || "hour";
      return rows
        .map((row, idx) => ({ row, idx }))
        .sort((a, b) => {
          const aDate = new Date(`${a.row?.[dKey] || ""}T${(a.row?.[tKey] || "00:00").slice(0, 5)}`);
          const bDate = new Date(`${b.row?.[dKey] || ""}T${(b.row?.[tKey] || "00:00").slice(0, 5)}`);
          const aTs = aDate.toString() === "Invalid Date" ? 0 : aDate.getTime();
          const bTs = bDate.toString() === "Invalid Date" ? 0 : bDate.getTime();
          return bTs - aTs;
        });
    }

    function renderTable(kind, headers, rows, withActions = false, limit = null) {
      const cfg = datasets[kind];
      if (!headers || !rows) {
        cfg.logsTable.innerHTML = "";
        return;
      }
      const isLongField = (h) =>
        LONG_TEXT_FIELDS.some((f) => normalizeHeaderName(f) === normalizeHeaderName(h));
      const sortedRows = sortRowsWithIndex(rows, headers);
      const displayRows = limit ? sortedRows.slice(0, limit) : sortedRows;
      const thead = `<thead><tr>${headers.map((h) => `<th>${escapeHtml(h)}</th>`).join("")}${withActions ? "<th>Actions</th>" : ""}</tr></thead>`;
      const tbody = `<tbody>${displayRows
        .map(({ row, idx: originalIdx }) => {
          const isEditing = editingState.kind === kind && editingState.idx === originalIdx;
          const cells = headers
            .map((h) => {
              const longField = isLongField(h);
              if (isEditing) {
                const extraClass = longField ? " long" : "";
                if (longField) {
                  return `<td><textarea class="inline-input${extraClass} multiline" data-edit-field="${escapeHtml(h)}" data-edit-kind="${kind}" data-edit-idx="${originalIdx}">${escapeHtml(
                    editingState.draft?.[h] ?? row[h] ?? ""
                  )}</textarea></td>`;
                }
                return `<td><input class="inline-input${extraClass}" data-edit-field="${escapeHtml(h)}" data-edit-kind="${kind}" data-edit-idx="${originalIdx}" value="${escapeHtml(
                  editingState.draft?.[h] ?? row[h] ?? ""
                )}"/></td>`;
              }
              const content = escapeHtml(row[h] ?? "");
              const wrapped = longField ? `<div class="clip-cell">${content}</div>` : content;
              return `<td>${wrapped}</td>`;
            })
            .join("");
          let actions = "";
          if (withActions) {
            if (isEditing) {
              actions = `<td class="row-actions"><button class="nav-btn small" data-save-row="${originalIdx}" data-kind="${kind}">Save</button><button class="nav-btn danger small" data-cancel-row="${originalIdx}" data-kind="${kind}">Cancel</button></td>`;
            } else {
              actions = `<td class="row-actions"><button class="nav-btn small" data-edit-row="${originalIdx}" data-kind="${kind}">Edit</button><button class="nav-btn danger small" data-delete-row="${originalIdx}" data-kind="${kind}">Delete</button></td>`;
            }
          }
          return `<tr data-row="${originalIdx}">${cells}${actions}</tr>`;
        })
        .join("")}</tbody>`;
      cfg.logsTable.innerHTML = `<div class="table-scroll"><table>${thead}${tbody}</table></div><div class="rowcount">${rows.length} rows</div>`;
      if (withActions) wireRowActions(kind);
    }

    function escapeHtml(str) {
      return String(str)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }

    function parseCSV(text) {
      const rows = [];
      let current = [];
      let value = "";
      let inQuotes = false;
      for (let i = 0; i < text.length; i++) {
        const c = text[i];
        if (inQuotes) {
          if (c === '"') {
            if (text[i + 1] === '"') {
              value += '"';
              i++;
            } else {
              inQuotes = false;
            }
          } else {
            value += c;
          }
        } else {
          if (c === '"') {
            inQuotes = true;
          } else if (c === ",") {
            current.push(value);
            value = "";
          } else if (c === "\n") {
            current.push(value);
            rows.push(current);
            current = [];
            value = "";
          } else if (c === "\r") {
            continue;
          } else {
            value += c;
          }
        }
      }
      if (value !== "" || current.length) {
        current.push(value);
        rows.push(current);
      }
      const headers = rows.shift() || [];
      const objects = rows.filter(r => r.length && r.some(cell => cell.trim() !== "")).map(r => {
        const obj = {};
        headers.forEach((h, idx) => obj[h.trim()] = r[idx] ?? "");
        return obj;
      });
      return { headers, rows: objects };
    }

    async function handleFile(kind, file) {
      const cfg = datasets[kind];
      if (!file) return;
      try {
        const text = await file.text();
        const parsed = parseCSV(text);
        if (!parsed.headers.length) throw new Error("No headers detected");
        const normalized = normalizeParsed(parsed, kind);
        const validateMsg = validateHeaders(kind, normalized.headers);
        if (validateMsg) throw new Error(validateMsg);
        const result = await persist(kind, normalized, file.name);
        setStatus(kind, `Imported ${result.added} new, ${result.skipped} existing (source: ${file.name})`, true, "import");
        showPopup(`Imported ${result.added} new, ${result.skipped} already present`, true);
      } catch (err) {
        setStatus(kind, err.message || "Failed to parse", false, "import");
        showPopup(err.message || "Import failed", false);
      }
    }

    function normalizeHeaderName(h) {
      return h
        .replace(/^\uFEFF/, "")
        .toLowerCase()
        .replace(/\u00a0/g, " ") // nbsp to space
        .replace(/[-_–—]+/g, " ")
        .replace(/\s+/g, " ")
        .trim();
    }

    function validateHeaders(kind, headers) {
      const expected = REQUIRED[kind];
      if (!expected) return "";
      const normalized = headers.map(normalizeHeaderName);
      const set = new Set(normalized);
      const aliasMap = ALIASES[kind] || {};
      const missing = [];
      expected.forEach(req => {
        const aliases = aliasMap[req] || [req];
        const found = aliases.some(a => set.has(normalizeHeaderName(a)));
        if (!found) missing.push(req);
      });
      return missing.length ? `Missing columns for ${kind}: ${missing.join(", ")}` : "";
    }

    function findHeader(headers, target) {
      const wanted = normalizeHeaderName(target);
      for (const h of headers) {
        if (normalizeHeaderName(h) === wanted) return h;
      }
      return null;
    }

    function normalizeTimestamp(val) {
      const raw = String(val ?? "").trim();
      if (!raw) return "";
      const hasTime = raw.includes("T") || raw.includes(" ");
      if (hasTime) return raw.replace(" ", "T");
      return raw;
    }

    function normalizeRows(headers, rows, kind) {
      const createdKey = findHeader(headers, "created time");
      const fileKey = findHeader(headers, "file name");
      const dateKey = findHeader(headers, "date") || fileKey || createdKey || "date";
      const hourKey = findHeader(headers, "hour") || findHeader(headers, "time");
      const habitsKey = findHeader(headers, "habits");
      const goodKey = findHeader(headers, "good sleep");
      const healthyKey = findHeader(headers, "healthy food");
      const otherKey = findHeader(headers, "other");
      const flagDefs = [
        { key: findHeader(headers, ">6h day byte"), label: ">6h day byte" },
        { key: findHeader(headers, ">1h masturbation"), label: ">1h masturbation" },
        { key: findHeader(headers, "<1h masturbation"), label: "<1h masturbation" },
        { key: findHeader(headers, "cum"), label: "cum" },
      ];

      const allowed = kind && REQUIRED[kind] ? REQUIRED[kind] : null;
      const allowedNormalized = allowed ? allowed.map(normalizeHeaderName) : null;
      const cleanedHeaders = headers.filter((h) => {
        const norm = normalizeHeaderName(h);
        if (allowedNormalized) return allowedNormalized.includes(norm);
        return ![
          "created time",
          "file name",
          "date",
          "time",
          "hour",
          "habits",
          "good sleep",
          "healthy food",
          ">6h day byte",
          ">1h masturbation",
          "<1h masturbation",
          "cum",
        ].includes(norm);
      });
      const normalizedHeaders = [];
      const desiredOrder =
        allowed ||
        [
          "date",
          "hour",
          "pain level",
          "fatigue level",
          "symptoms",
          "area",
          "activities",
          "habits",
          "coffee",
          "other",
          "medicines",
          "note",
        ];
      [...desiredOrder, ...cleanedHeaders].forEach((h) => {
        const norm = normalizeHeaderName(h);
        if (!normalizedHeaders.some((x) => normalizeHeaderName(x) === norm)) {
          normalizedHeaders.push(h === "file name" ? "date" : h);
        }
      });

      let changed = normalizeHeaderName(createdKey || "") === "created time" || !!fileKey;
      const normalizedRows = (rows || []).map((row) => {
        const rawFile = fileKey ? row[fileKey] : "";
        const rawCreated = createdKey ? row[createdKey] : "";
        const rawDate = dateKey ? row[dateKey] : "";
        const rawHour = hourKey ? row[hourKey] : "";
        const rawHabits = habitsKey ? row[habitsKey] : "";
        const rawGood = goodKey ? row[goodKey] : "";
        const rawHealthy = healthyKey ? row[healthyKey] : "";

        const preferred = rawDate || rawFile || rawCreated || "";
        const normalizedValue = normalizeTimestamp(preferred);
        let datePart = normalizedValue;
        let hourPart = "";
        if (normalizedValue.includes("T")) {
          const [d, t] = normalizedValue.split("T");
          datePart = d;
          hourPart = (t || "").slice(0, 5);
        }
        if (!hourPart && rawHour) {
          hourPart = String(rawHour).slice(0, 5);
        }
        if (!hourPart) hourPart = "21:00";

        const next = { ...row, date: datePart, hour: hourPart };
        if (kind === "pain") {
          if (habitsKey) delete next[habitsKey];
          if (goodKey) delete next[goodKey];
          if (healthyKey) delete next[healthyKey];
          flagDefs.forEach((f) => {
            if (f.key && f.key in next) delete next[f.key];
          });
          if (otherKey && otherKey in next) delete next[otherKey];

        const habitTokens = new Set();
        const addTokens = (val) => {
          String(val || "")
            .split(",")
            .map((s) => s.trim().toLowerCase())
            .filter((s) => s && !["false", "true", "yes", "1", "no", "0"].includes(s))
            .forEach((s) => habitTokens.add(s));
        };
          addTokens(rawHabits);
          addTokens(rawGood);
          addTokens(rawHealthy);
          const goodYes = habitTokens.has("good sleep") || /^yes|true|1$/i.test(String(rawGood || "").trim());
          const healthyYes =
            habitTokens.has("healthy food") || /^yes|true|1$/i.test(String(rawHealthy || "").trim());
          const habitList = [];
          if (goodYes) habitList.push("good sleep");
          if (healthyYes) habitList.push("healthy food");
          const extraHabits = Array.from(habitTokens).filter(
            (t) => t && t !== "good sleep" && t !== "healthy food"
          );
          if (extraHabits.length) habitList.push(...extraHabits);
          next["habits"] = habitList.join(", ");

        const otherTokens = new Set();
        const addOther = (label, val) => {
          const v = String(val || "").trim();
          if (!v) return;
          const lower = v.toLowerCase();
          if (["yes", "true", "1"].includes(lower)) {
            otherTokens.add(label);
          } else if (!["false", "no", "0"].includes(lower)) {
            otherTokens.add(v);
          }
        };
        flagDefs.forEach((f) => addOther(f.label, f.key ? row[f.key] : ""));
          if (otherKey) {
            String(row[otherKey] || "")
              .split(",")
              .map((s) => s.trim())
              .filter((s) => s && !["false", "true", "yes", "1", "no", "0"].includes(s.toLowerCase()))
              .forEach((s) => otherTokens.add(s));
          }
          next["other"] = Array.from(otherTokens).join(", ");
          if (allowedNormalized) {
            Object.keys(next).forEach((key) => {
              if (!allowedNormalized.includes(normalizeHeaderName(key))) {
                delete next[key];
              }
            });
          }
        } else if (allowedNormalized) {
          // strip any fields not in allowed when not pain
          Object.keys(next).forEach((key) => {
            if (!allowedNormalized.includes(normalizeHeaderName(key))) {
              delete next[key];
            }
          });
        }

        if (fileKey && fileKey in next) delete next[fileKey];
        if (createdKey && createdKey in next) delete next[createdKey];
        if (hourKey && hourKey !== "hour" && hourKey in next) delete next[hourKey];

        if (
          next.date !== rawDate ||
          (fileKey && rawFile && next.date !== rawFile) ||
          (createdKey && rawCreated && next.date !== rawCreated) ||
          next.hour !== rawHour ||
          (kind === "pain" && (next.habits !== rawHabits || next.other !== (otherKey ? row[otherKey] : "")))
        ) {
          changed = true;
        }
        return next;
      });
      return { headers: normalizedHeaders, rows: normalizedRows, changed };
    }

    function collectOptions(field) {
      const store = dataStore.pain;
      const options = new Set();
      if (store?.rows?.length) {
        const key = findHeader(store.headers, field) || field;
        store.rows.forEach((row) => {
          const val = row?.[key];
          if (!val) return;
          String(val)
            .split(",")
            .map((s) => s.trim())
            .filter((s) => s && !["true", "false", "yes", "no", "0", "1"].includes(s.toLowerCase()))
            .forEach((s) => options.add(s));
        });
      }
      return Array.from(options);
    }

    const logCollapsed = { diary: true, pain: true };
    let editingState = { kind: null, idx: null, draft: null };

    function renderLog(kind) {
      const data = dataStore[kind];
      if (!data?.headers || !data.rows) return;
      const btn = document.querySelector(`[data-toggle-log="${kind}"]`);
      const wrap = datasets[kind]?.logsTable;
      if (logCollapsed[kind]) {
        if (wrap) wrap.innerHTML = "";
        if (btn) btn.textContent = "Expand ◀";
        return;
      }
      renderTable(kind, data.headers, data.rows, true, null);
      if (btn) btn.textContent = "Collapse ▼";
    }

    function wireLogToggles() {
      document.querySelectorAll("[data-toggle-log]").forEach((btn) => {
        btn.addEventListener("click", () => {
          const kind = btn.dataset.toggleLog;
          if (!kind) return;
          logCollapsed[kind] = !logCollapsed[kind];
          renderLog(kind);
        });
      });
    }

    function renderOptionButtons(field, containerId, preselectAll = false) {
      const el = document.getElementById(containerId);
      if (!el) return;
      const values = optionsCache[field] || [];
      if (!values.length) {
        el.innerHTML = `<span style="color:var(--muted); font-size:13px;">No ${field} options yet</span>`;
        return;
      }
      el.innerHTML = values
        .map(
          (v) =>
            `<button type="button" class="chip-btn${preselectAll ? " active" : ""}" data-value="${escapeHtml(
              v
            )}">${escapeHtml(v)}</button>`
        )
        .join("");
      el.querySelectorAll(".chip-btn").forEach((btn) => {
        btn.addEventListener("click", () => btn.classList.toggle("active"));
      });
    }

    function wireRowActions(kind) {
      const cfg = datasets[kind];
      if (!cfg?.logsTable) return;
      cfg.logsTable.querySelectorAll("[data-edit-row]").forEach((btn) => {
        btn.onclick = () => editRow(kind, parseInt(btn.dataset.editRow, 10));
      });
      cfg.logsTable.querySelectorAll("[data-delete-row]").forEach((btn) => {
        btn.onclick = () => deleteRow(kind, parseInt(btn.dataset.deleteRow, 10));
      });
      cfg.logsTable.querySelectorAll("[data-save-row]").forEach((btn) => {
        btn.onclick = () => saveInline(kind, parseInt(btn.dataset.saveRow, 10));
      });
      cfg.logsTable.querySelectorAll("[data-cancel-row]").forEach((btn) => {
        btn.onclick = () => cancelInline(kind);
      });
      attachInlineInputs(kind);
    }

    function sanitizeRowForHeaders(row, headers) {
      const clean = {};
      headers.forEach((h) => {
        clean[h] = row[h] ?? "";
      });
      return clean;
    }

    async function saveRows(kind, rows) {
      const headers = dataStore[kind]?.headers || REQUIRED[kind] || [];
      const normalized = normalizeRows(headers, rows, kind);
      const sortedRows = sortRowsByDateTime(normalized.rows, normalized.headers);
      const payload = {
        source: "manual edit",
        imported_at: new Date().toISOString(),
        headers: normalized.headers,
        rows: sortedRows,
      };
      try {
        const res = await apiFetch(`/api/files/${datasets[kind].file}`, {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });
        if (res.status === 401) throw new Error("Please log in to save");
        if (!res.ok) throw new Error(`Server returned ${res.status}`);
        dataStore[kind] = payload;
        renderLog(kind);
        setStatus(kind, "Saved edits", true, "logs");
        if (kind === "pain") {
          buildOptionCacheFromStore();
          renderPainOptionButtons();
        }
        renderDashboard();
      } catch (err) {
        setStatus(kind, err.message || "Failed to save edits", false, "logs");
      }
    }

    function editRow(kind, idx) {
      const rows = dataStore[kind]?.rows || [];
      const headers = dataStore[kind]?.headers || [];
      const row = rows[idx];
      if (!row) return;
      editingState = { kind, idx, draft: sanitizeRowForHeaders(row, headers) };
      renderLog(kind);
    }

    function cancelInline(kind) {
      editingState = { kind: null, idx: null, draft: null };
      renderLog(kind);
    }

    function attachInlineInputs(kind) {
      const cfg = datasets[kind];
      if (!cfg?.logsTable) return;
      cfg.logsTable.querySelectorAll(".inline-input[data-edit-kind]").forEach((input) => {
        input.addEventListener("input", (e) => {
          const field = e.target.dataset.editField;
          const idx = parseInt(e.target.dataset.editIdx, 10);
          if (editingState.kind !== kind || editingState.idx !== idx) return;
          if (!editingState.draft) editingState.draft = {};
          editingState.draft[field] = e.target.value;
        });
      });
    }

    function saveInline(kind, idx) {
      if (editingState.kind !== kind || editingState.idx !== idx) return;
      const rows = dataStore[kind]?.rows || [];
      const headers = dataStore[kind]?.headers || [];
      const draft = sanitizeRowForHeaders(editingState.draft || {}, headers);
      const newRows = [...rows];
      newRows[idx] = draft;
      editingState = { kind: null, idx: null, draft: null };
      saveRows(kind, newRows);
    }

    function deleteRow(kind, idx) {
      const rows = dataStore[kind]?.rows || [];
      if (!rows[idx]) return;
      const ok = confirm(`Delete row #${idx + 1}?`);
      if (!ok) return;
      const newRows = rows.filter((_, i) => i !== idx);
      saveRows(kind, newRows);
    }

    function wireAutotherapyTabs() {
      const buttons = document.querySelectorAll("[data-autotherapy]");
      const panels = document.querySelectorAll("[data-autotherapy-panel]");
      const setActive = (key) => {
        buttons.forEach((btn) => btn.classList.toggle("active", btn.dataset.autotherapy === key));
        panels.forEach((panel) => panel.classList.toggle("hidden", panel.dataset.autotherapyPanel !== key));
      };
      buttons.forEach((btn) => {
        btn.addEventListener("click", () => setActive(btn.dataset.autotherapy));
      });
    }

    function renderPainOptionButtons() {
      renderOptionButtons("area", "area-options", false);
      renderOptionButtons("symptoms", "symptoms-options", false);
      renderOptionButtons("activities", "activities-options", false);
      renderOptionButtons("medicines", "medicines-options", true);
      renderOptionButtons("habits", "habits-options", false);
      renderOptionButtons("other", "other-options", false);
    }

    function renderOptionEditor(field) {
      const container = document.getElementById(`${field}-editor`);
      if (!container) return;
      const listContainer = document.getElementById(`${field}-options`);
      if (listContainer) listContainer.classList.add("hidden");
      const opts = optionsCache[field] || [];
      const listHtml = opts.length
        ? opts
            .map(
              (v) => `
            <div class="chip-editor-row">
              <span>${escapeHtml(v)}</span>
              <div class="chip-editor-actions">
                <button type="button" data-action="edit" data-value="${escapeHtml(v)}" data-field="${field}">Edit</button>
                <button type="button" data-action="delete" data-value="${escapeHtml(v)}" data-field="${field}">Delete</button>
              </div>
            </div>`
            )
            .join("")
        : `<div style="color:var(--muted); font-size:13px;">No ${escapeHtml(field)} options yet</div>`;
      container.innerHTML = `
        <div class="chip-editor-list">${listHtml}</div>
        <div class="chip-editor-add">
          <input type="text" placeholder="Add ${escapeHtml(field)}" data-new="${field}" />
          <button type="button" data-action="add" data-field="${field}">Add</button>
        </div>
      `;
      container.querySelectorAll("[data-action]").forEach((btn) => {
        btn.addEventListener("click", () => handleEditorAction(btn.dataset));
      });
    }

    function handleEditorAction(dataset) {
      const field = dataset.field;
      if (!field) return;
      const action = dataset.action;
      const current = optionsCache[field] || [];
      if (action === "add") {
        const input = document.querySelector(`input[data-new="${field}"]`);
        const val = input?.value?.trim();
        if (val) {
          optionsCache[field] = dedupe([...current, val]);
          removedOptions[field] = (removedOptions[field] || []).filter((v) => v !== val);
          input.value = "";
          renderOptionEditor(field);
          renderPainOptionButtons();
        }
      } else if (action === "delete") {
        const val = dataset.value;
        optionsCache[field] = current.filter((v) => v !== val);
        if (!removedOptions[field]) removedOptions[field] = [];
        if (!removedOptions[field].includes(val)) removedOptions[field].push(val);
        renderOptionEditor(field);
        renderPainOptionButtons();
      } else if (action === "edit") {
        const val = dataset.value;
        const next = prompt(`Rename ${field}`, val);
        if (next && next.trim()) {
          const trimmed = next.trim();
          optionsCache[field] = dedupe(current.map((v) => (v === val ? trimmed : v)));
          if (!removedOptions[field]) removedOptions[field] = [];
          if (!removedOptions[field].includes(val)) removedOptions[field].push(val);
          removedOptions[field] = removedOptions[field].filter((v) => v !== trimmed);
          renderOptionEditor(field);
          renderPainOptionButtons();
        }
      }
      persistOptionCache();
      const listContainer = document.getElementById(`${field}-options`);
      if (listContainer) listContainer.classList.add("hidden");
    }

    function dedupe(list) {
      return Array.from(new Set((list || []).filter(Boolean).map((v) => v.trim())));
    }

    function wireOptionEditors() {
      document.querySelectorAll("[data-edit]").forEach((btn) => {
        btn.addEventListener("click", () => {
          const field = btn.dataset.edit;
          if (!field) return;
          const editor = document.getElementById(`${field}-editor`);
          const listContainer = document.getElementById(`${field}-options`);
          if (!editor) return;
          const isHidden = editor.classList.contains("hidden");
          document.querySelectorAll(".chip-editor").forEach((ed) => ed.classList.add("hidden"));
          document.querySelectorAll(".chip-row").forEach((row) => row.classList.remove("hidden"));
          if (isHidden) {
            editor.classList.remove("hidden");
            if (listContainer) listContainer.classList.add("hidden");
            renderOptionEditor(field);
          }
        });
      });
    }

    function selectedOptions(containerId) {
      const el = document.getElementById(containerId);
      if (!el) return [];
      return Array.from(el.querySelectorAll(".chip-btn.active")).map((btn) => btn.dataset.value || "");
    }

    function normalizeParsed(parsed, kind) {
      if (!parsed?.headers || !Array.isArray(parsed.rows)) return parsed;
      const result = normalizeRows(parsed.headers, parsed.rows, kind);
      return { headers: result.headers, rows: result.rows };
    }

    function normalizeDataset(data, kind) {
      if (!data?.headers || !Array.isArray(data.rows)) return { data, changed: false };
      const normalized = normalizeRows(data.headers, data.rows, kind);
      return {
        data: { ...data, headers: normalized.headers, rows: normalized.rows },
        changed: normalized.changed,
      };
    }

    function entryDateFromRow(row, headers) {
      const dateKey = findHeader(headers, "date") || "date";
      const timeKey = findHeader(headers, "hour") || "hour";
      const dateVal = (row?.[dateKey] || "").trim();
      const timeVal = (row?.[timeKey] || "").trim() || "21:00";
      if (!dateVal) return null;
      const d = new Date(`${dateVal}T${timeVal}`);
      return d.toString() === "Invalid Date" ? null : d;
    }

    async function persistNormalized(kind, payload) {
      const cfg = datasets[kind];
      if (!cfg) return;
      try {
        const res = await apiFetch(`/api/files/${cfg.file}`, {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });
        if (res.status === 401) throw new Error("Please log in to save");
        if (!res.ok) throw new Error(`Server returned ${res.status}`);
      } catch (err) {
        console.warn("Failed to persist normalized data", err);
      }
    }

    async function persist(kind, parsed, sourceName) {
      const cfg = datasets[kind];
      try {
        const normalizedIncoming = normalizeRows(parsed.headers, parsed.rows, kind);
        const existingNormalized = normalizeRows(
          dataStore[kind]?.headers || normalizedIncoming.headers,
          dataStore[kind]?.rows || [],
          kind
        );
        const mergedHeaders = Array.from(
          new Set([...(existingNormalized.headers || []), ...(normalizedIncoming.headers || [])])
        );
        const dateKey = findHeader(mergedHeaders, "date") || "date";
        const timeKey = findHeader(mergedHeaders, "hour") || "hour";
        const seen = new Set(
          existingNormalized.rows.map(r => `${r[dateKey] || ""}T${(r[timeKey] || "21:00").slice(0,5)}`)
        );
        let added = 0;
        let skipped = 0;
        const mergedRows = [...existingNormalized.rows];

        normalizedIncoming.rows.forEach(r => {
          const stamp = `${(r[dateKey] || "").trim()}T${(r[timeKey] || "21:00").slice(0,5)}`;
          if (!stamp.trim()) return;
          if (seen.has(stamp)) {
            skipped += 1;
          } else {
            seen.add(stamp);
            mergedRows.push(r);
            added += 1;
          }
        });

        const sortedRows = sortRowsByDateTime(mergedRows, mergedHeaders);
        const payload = {
          source: sourceName,
          imported_at: new Date().toISOString(),
          headers: mergedHeaders,
          rows: sortedRows,
        };
        const res = await apiFetch(`/api/files/${cfg.file}`, {
          method: "PUT",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });
        if (res.status === 401) {
          throw new Error("Please log in to save");
        }
        if (!res.ok) {
          throw new Error(`Server returned ${res.status}`);
        }
        dataStore[kind] = payload;
        renderLog(kind);
        setStatus(kind, `Saved to ${cfg.file} (${mergedRows.length} total rows)`, true, "import");
        setStatus(kind, `Updated ${mergedRows.length} rows from ${sourceName}`, true, "logs");
        renderDashboard();
        return { added, skipped };
      } catch (err) {
        console.error(err);
        setStatus(kind, err.message || "Failed to save", false, "import");
        throw err;
      }
    }

    function wireEntryTabs() {
      const buttons = document.querySelectorAll(".entry-btn");
      const panels = document.querySelectorAll("[data-entry-panel]");
      const autotherapyTab = document.getElementById("autotherapy-tab");
      const setAutotherapyLabel = (key) => {
        if (!autotherapyTab) return;
        const arrow = key === "autotherapy" ? "▼" : "◀";
        autotherapyTab.textContent = `Autotherapy ${arrow}`;
      };
      const setActive = (key) => {
        if (!key) return;
        buttons.forEach((btn) => btn.classList.toggle("active", btn.dataset.entry === key));
        panels.forEach((panel) => panel.classList.toggle("hidden", panel.dataset.entryPanel !== key));
        setAutotherapyLabel(key);
      };
      buttons.forEach((btn) => {
        btn.addEventListener("click", () => setActive(btn.dataset.entry));
      });
      if (buttons.length) {
        const current = document.querySelector(".entry-btn.active")?.dataset.entry || buttons[0].dataset.entry;
        setActive(current);
      }
      entryTabSetter = setActive;
    }

    function wirePainForm() {
      const form = document.getElementById("pain-form");
      const status = document.getElementById("pain-form-status");
      if (!form) return;

      const setStatus = (msg, ok = false) => {
        if (!status) return;
        status.innerHTML = msg ? `<span class="${ok ? "ok" : "err"}">${ok ? "Saved" : "Error"}:</span> ${escapeHtml(msg)}` : "";
      };

      const setDefaultDate = () => {
        const input = form.querySelector('input[name="pain-date"]');
        if (input && !input.value) {
          const now = new Date();
          const localIso = new Date(now.getTime() - now.getTimezoneOffset() * 60000).toISOString().slice(0, 16);
          input.value = localIso;
        }
      };

      setDefaultDate();
      renderPainOptionButtons();

      form.addEventListener("submit", async (e) => {
        e.preventDefault();
        const data = new FormData(form);
        const toParts = (val) => {
          const fallback = new Date();
          const parsed = val ? new Date(val) : fallback;
          const good = parsed.toString() !== "Invalid Date" ? parsed : fallback;
          const iso = new Date(good.getTime() - good.getTimezoneOffset() * 60000).toISOString();
          return { date: iso.slice(0, 10), time: iso.slice(11, 16) };
        };
        const parts = toParts(data.get("pain-date"));
        const areas = selectedOptions("area-options").join(", ");
        const symptoms = selectedOptions("symptoms-options").join(", ");
        const activities = selectedOptions("activities-options").join(", ");
        const medicines = selectedOptions("medicines-options").join(", ");
        const other = selectedOptions("other-options").join(", ");
        const habits = selectedOptions("habits-options").join(", ");
        const row = {
          "date": parts.date,
          "hour": parts.time,
          "pain level": data.get("pain-level") || "",
          "fatigue level": data.get("fatigue-level") || "",
          "symptoms": symptoms,
          "area": areas,
          "activities": activities,
          "habits": habits,
          "coffee": data.get("coffee-count") || "",
          "other": other,
          "medicines": medicines,
          "note": data.get("pain-note") || "",
        };
        const parsed = { headers: REQUIRED.pain, rows: [row] };
        try {
          await persist("pain", parsed, "manual form");
          setStatus("Saved new pain entry", true);
          buildOptionCacheFromStore();
          renderPainOptionButtons();
          optionFields.forEach((field) => {
            const editor = document.getElementById(`${field}-editor`);
            if (editor && !editor.classList.contains("hidden")) renderOptionEditor(field);
          });
          form.reset();
          setDefaultDate();
        } catch (err) {
          setStatus(err.message || "Failed to save pain entry", false);
        }
      });
    }

    function wireDropZones() {
      document.querySelectorAll('input[type="file"]').forEach(input => {
        input.addEventListener("change", (e) => {
          const kind = e.target.dataset.kind;
          const file = e.target.files?.[0];
          handleFile(kind, file);
        });
        const label = input.closest(".drop");
        label.addEventListener("dragover", (e) => { e.preventDefault(); label.classList.add("hover"); });
        label.addEventListener("dragleave", () => label.classList.remove("hover"));
        label.addEventListener("drop", (e) => {
          e.preventDefault();
          label.classList.remove("hover");
          const file = e.dataTransfer.files?.[0];
          handleFile(input.dataset.kind, file);
        });
      });
    }

    function wireNav() {
      const buttons = document.querySelectorAll(".nav-btn[data-target]");
      const sections = {
        dashboard: document.getElementById("dashboard-section"),
        newlog: document.getElementById("newlog-section"),
        logs: document.getElementById("logs-section"),
        import: document.getElementById("import-section"),
      };
      buttons.forEach(btn => {
        btn.addEventListener("click", () => {
          const target = btn.dataset.target;
          buttons.forEach(b => b.classList.toggle("active", b === btn));
          Object.entries(sections).forEach(([key, el]) => {
            el.classList.toggle("hidden", key !== target);
          });
          if (target === "newlog" && entryTabSetter) {
            const current = document.querySelector(".entry-btn.active")?.dataset.entry
              || document.querySelector(".entry-btn")?.dataset.entry;
            entryTabSetter(current);
          }
        });
      });
    }

    function getDateRange() {
      const fromInput = document.getElementById("filter-from");
      const toInput = document.getElementById("filter-to");
      const fromVal = fromInput?.value ? new Date(fromInput.value) : null;
      const toVal = toInput?.value ? new Date(toInput.value) : null;
      return {
        from: fromVal && !isNaN(fromVal) ? fromVal : null,
        to: toVal && !isNaN(toVal) ? toVal : null,
      };
    }

    function previousRange(range) {
      if (!range?.from) return null;
      const to = range.to && !isNaN(range.to) ? range.to : new Date();
      const duration = to.getTime() - range.from.getTime();
      if (duration <= 0) return null;
      const prevTo = new Date(range.from.getTime() - 24 * 60 * 60 * 1000);
      const prevFrom = new Date(prevTo.getTime() - duration);
      return { from: prevFrom, to: prevTo };
    }

    function renderDashboard() {
      const container = document.getElementById("dash-cards");
      const graphs = document.getElementById("dash-graphs");
      if (!container || !graphs) return;
      const range = getDateRange();
      const diary = applyDateFilter(dataStore.diary, range);
      const pain = applyDateFilter(dataStore.pain, range);
      const prevRange = previousRange(range);
      const diaryPrev = prevRange ? applyDateFilter(dataStore.diary, prevRange) : null;
      const painPrev = prevRange ? applyDateFilter(dataStore.pain, prevRange) : null;

      const diaryCount = diary?.rows?.length || 0;
      const painCount = pain?.rows?.length || 0;
      const diaryMoodAvg = avgField(diary, "mood level");
      const diaryDepAvg = avgField(diary, "depression");
      const diaryAnxAvg = avgField(diary, "anxiety");
      const painLevelAvg = avgField(pain, "pain level");
      const fatigueAvg = avgField(pain, "fatigue level");
      const diaryPrevCount = diaryPrev?.rows?.length ?? null;
      const painPrevCount = painPrev?.rows?.length ?? null;
      const diaryPrevMoodAvg = avgField(diaryPrev, "mood level");
      const diaryPrevDepAvg = avgField(diaryPrev, "depression");
      const diaryPrevAnxAvg = avgField(diaryPrev, "anxiety");
      const painPrevLevelAvg = avgField(painPrev, "pain level");
      const fatiguePrevAvg = avgField(painPrev, "fatigue level");

      const cards = [
        { label: "Diary entries", value: diaryCount, prev: diaryPrevCount },
        { label: "Pain entries", value: painCount, prev: painPrevCount },
        { label: "Mood avg", value: diaryMoodAvg ?? "–", prev: diaryPrevMoodAvg },
        { label: "Depression avg", value: diaryDepAvg ?? "–", prev: diaryPrevDepAvg },
        { label: "Anxiety avg", value: diaryAnxAvg ?? "–", prev: diaryPrevAnxAvg },
        { label: "Pain avg", value: painLevelAvg ?? "–", prev: painPrevLevelAvg },
        { label: "Fatigue avg", value: fatigueAvg ?? "–", prev: fatiguePrevAvg },
      ];

      container.innerHTML = cards
        .map((c) => {
          const delta = calcDelta(c.value, c.prev);
          const deltaHtml = delta ? `<span class="delta ${delta.cls}">${escapeHtml(delta.text)}</span>` : "";
          return `
            <div class="dash-card">
              <div class="dash-label">${escapeHtml(c.label)}</div>
              <div class="dash-value">${escapeHtml(c.value)}${deltaHtml}</div>
            </div>
          `;
        })
        .join("");

      const graphDefs = [
        { id: "graph-diary-mood", title: "Diary: Mood over time", yLabel: "Mood level", data: timeSeries(diary, "mood level") },
        { id: "graph-pain-level", title: "Pain: Pain level over time", yLabel: "Pain level", data: timeSeries(pain, "pain level") },
      ];

      graphs.innerHTML = graphDefs
        .map(
          (g) => `
            <div class="graph-card">
              <div class="graph-title">${escapeHtml(g.title)}</div>
              <canvas id="${g.id}"></canvas>
            </div>
          `
        )
        .join("");

      graphDefs.forEach((g, idx) => {
        const canvas = document.getElementById(g.id);
        drawLineChart(canvas, g.data, idx, { yLabel: g.yLabel });
      });
    }

    function avgField(store, field) {
      if (!store?.rows?.length) return null;
      const key = findHeader(store.headers, field) || field;
      let sum = 0;
      let count = 0;
      store.rows.forEach((row) => {
        const val = parseFloat(row[key]);
        if (!Number.isNaN(val)) {
          sum += val;
          count += 1;
        }
      });
      if (!count) return null;
      return parseFloat((sum / count).toFixed(2));
    }

    function calcDelta(current, previous) {
      const curNum = toNumber(current);
      const prevNum = toNumber(previous);
      if (curNum === null || prevNum === null || prevNum === 0) return null;
      const pct = ((curNum - prevNum) / prevNum) * 100;
      return {
        text: `${pct > 0 ? "+" : ""}${pct.toFixed(0)}%`,
        cls: pct > 0 ? "positive" : pct < 0 ? "negative" : "neutral",
      };
    }

    function toNumber(val) {
      const n = Number(val);
      return Number.isFinite(n) ? n : null;
    }

    function timeSeries(store, field) {
      if (!store?.rows?.length) return [];
      const key = findHeader(store.headers, field) || field;
      return store.rows
        .map((row) => {
          const d = entryDateFromRow(row, store.headers);
          const v = parseFloat(row[key]);
          return { t: d, v };
        })
        .filter((p) => p.t && p.t.toString() !== "Invalid Date" && !Number.isNaN(p.v))
        .sort((a, b) => a.t - b.t);
    }

    const graphMeta = {};

    function drawLineChart(canvas, data, idx, opts = {}) {
      if (!canvas || !canvas.getContext) return;
      const ctx = canvas.getContext("2d");
      const width = (canvas.width = canvas.offsetWidth || 320);
      const height = (canvas.height = canvas.offsetHeight || 180);
      ctx.clearRect(0, 0, width, height);
      ctx.strokeStyle = [ "#ff5e8a", "#ff8fb1", "#ffb3c9" ][idx % 3];
      ctx.lineWidth = 2;
      ctx.fillStyle = "rgba(255,255,255,0.04)";
      ctx.fillRect(0, 0, width, height);
      if (!data.length) {
        ctx.fillStyle = "rgba(226,232,240,0.7)";
        ctx.fillText("No data yet", 12, 20);
        return;
      }
      const yBounds = getYBounds(opts.yLabel, data);
      const minY = yBounds.min;
      const maxY = yBounds.max;
      const minX = data[0].t.getTime();
      const maxX = data[data.length - 1].t.getTime();
      const startTs = minX;
      const pad = 28;
      ctx.beginPath();
      const points = [];
      data.forEach((pt, i) => {
        const x = scale(pt.t.getTime(), minX, maxX || minX + 1, pad, width - pad);
        const y = scale(pt.v, maxY === minY ? minY - 1 : minY, maxY === minY ? minY + 1 : maxY, height - pad, pad);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
        points.push({ x, y, ...pt });
      });
      ctx.stroke();
      ctx.fillStyle = ctx.strokeStyle;
      data.forEach((pt) => {
        const x = scale(pt.t.getTime(), minX, maxX || minX + 1, pad, width - pad);
        const y = scale(pt.v, maxY === minY ? minY - 1 : minY, maxY === minY ? minY + 1 : maxY, height - pad, pad);
        ctx.beginPath();
        ctx.arc(x, y, 3, 0, Math.PI * 2);
        ctx.fill();
      });

      // axis ticks
      drawAxes(ctx, width, height, pad, minX, maxX, minY, maxY, data, startTs);

      graphMeta[canvas.id] = { points, yLabel: opts.yLabel || "Value", startTime: startTs };
      canvas.onmousemove = (e) => handleHover(canvas, e);
      canvas.onmouseleave = () => hideTooltip();
    }

    function scale(val, min, max, outMin, outMax) {
      if (max === min) return (outMin + outMax) / 2;
      return outMin + ((val - min) / (max - min)) * (outMax - outMin);
    }

    function getYBounds(label, data) {
      const rawMin = Math.min(...data.map(d => d.v));
      const rawMax = Math.max(...data.map(d => d.v));
      const normLabel = (label || "").toLowerCase();
      const preset = ["pain", "fatigue", "mood", "depression", "anxiety"].some(k => normLabel.includes(k));
      let min = preset ? 0 : rawMin;
      let max = preset ? 10 : rawMax;
      if (!preset) {
        const pad = Math.max(1, (rawMax - rawMin) * 0.1);
        min = rawMin - pad;
        max = rawMax + pad;
      }
      if (min === max) {
        min -= 1;
        max += 1;
      }
      return { min, max };
    }

    function drawAxes(ctx, width, height, pad, minX, maxX, minY, maxY, data, startTs) {
      ctx.strokeStyle = "rgba(226,232,240,0.2)";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(pad, pad);
      ctx.lineTo(pad, height - pad);
      ctx.lineTo(width - pad, height - pad);
      ctx.stroke();

      ctx.fillStyle = "rgba(226,232,240,0.7)";
      ctx.font = "10px Manrope, sans-serif";
      ctx.textAlign = "right";
      const yTicks = 5;
      for (let i = 0; i <= yTicks; i++) {
        const v = minY + ((maxY - minY) * i) / yTicks;
        const y = scale(v, minY, maxY, height - pad, pad);
        ctx.fillText(v.toFixed(0), pad - 6, y + 3);
        ctx.strokeStyle = "rgba(226,232,240,0.08)";
        ctx.beginPath();
        ctx.moveTo(pad + 2, y);
        ctx.lineTo(width - pad, y);
        ctx.stroke();
      }

      const xLabels = pickXLabels(data, startTs, maxX);
      ctx.textAlign = "center";
      xLabels.forEach((lbl) => {
        const x = scale(lbl.time, minX, maxX || minX + 1, pad, width - pad);
        ctx.fillText(lbl.text, x, height - pad + 12);
        ctx.strokeStyle = "rgba(226,232,240,0.08)";
        ctx.beginPath();
        ctx.moveTo(x, height - pad);
        ctx.lineTo(x, pad);
        ctx.stroke();
      });
    }

    function pickXLabels(data, startTs, endTs) {
      const labels = [];
      if (!data.length) return labels;
      const formatter = new Intl.DateTimeFormat(undefined, { month: "short", day: "numeric" });
      const steps = 4;
      for (let i = 0; i <= steps; i++) {
        const frac = i / steps;
        const time = startTs + (endTs - startTs) * frac;
        labels.push({ time, text: formatter.format(new Date(time)) });
      }
      return labels;
    }

    function handleHover(canvas, evt) {
      const meta = graphMeta[canvas.id];
      if (!meta || !meta.points?.length) return hideTooltip();
      const rect = canvas.getBoundingClientRect();
      const x = evt.clientX - rect.left;
      const y = evt.clientY - rect.top;
      let closest = null;
      let minDist = Infinity;
      meta.points.forEach((p) => {
        const dx = p.x - x;
        const dy = p.y - y;
        const dist = Math.hypot(dx, dy);
        if (dist < minDist) {
          minDist = dist;
          closest = p;
        }
      });
      if (!closest || minDist > 12) return hideTooltip();
      const tooltip = getTooltip();
      const start = meta.startTime || (meta.points[0]?.t?.getTime?.() ?? 0);
      const dateText = new Intl.DateTimeFormat(undefined, { month: "short", day: "numeric" }).format(closest.t);
      tooltip.innerHTML = `<strong>${meta.yLabel}:</strong> ${closest.v}<br/><span style="color:${'var(--muted)'}">${dateText}</span>`;
      tooltip.style.left = `${evt.clientX + 12}px`;
      tooltip.style.top = `${evt.clientY + 12}px`;
      tooltip.style.opacity = "1";
    }

    function hideTooltip() {
      const t = document.getElementById("tooltip");
      if (t) t.style.opacity = "0";
    }

    function getTooltip() {
      let t = document.getElementById("tooltip");
      if (!t) {
        t = document.createElement("div");
        t.id = "tooltip";
        t.className = "tooltip";
        document.body.appendChild(t);
      }
      return t;
    }

    function setQuickActive(btn) {
      document.querySelectorAll(".quick-btn").forEach(b => b.classList.remove("active"));
      btn.classList.add("active");
    }

    function clearQuickActive() {
      document.querySelectorAll(".quick-btn").forEach(b => b.classList.remove("active"));
    }

    function toCSV(headers, rows) {
      const esc = (val) => {
        const s = String(val ?? "");
        if (s.includes(",") || s.includes('"') || s.includes("\n")) {
          return `"${s.replace(/"/g, '""')}"`;
        }
        return s;
      };
      const head = headers.map(esc).join(",");
      const body = rows.map(r => headers.map(h => esc(r[h])).join(",")).join("\n");
      return `${head}\n${body}`;
    }

    function wireExport() {
      document.querySelectorAll("[data-export]").forEach(btn => {
        btn.addEventListener("click", () => {
          const kind = btn.dataset.export;
          const data = dataStore[kind];
          try {
            if (!data || !data.headers || !data.rows) {
              throw new Error("No data loaded yet. Import first.");
            }
            const blob = new Blob([toCSV(data.headers, data.rows)], { type: "text/csv;charset=utf-8" });
            const filename = `${kind}.csv`;
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
            showPopup(`Exported ${kind} as ${filename}`, true);
          } catch (err) {
            showPopup(err.message || "Export failed", false);
          }
        });
      });
    }

    function wirePurge() {
      document.querySelectorAll("[data-purge]").forEach(btn => {
        btn.addEventListener("click", async () => {
          const kind = btn.dataset.purge;
          try {
            const confirmFirst = confirm(`Are you sure you want to purge all ${kind} data?`);
            if (!confirmFirst) return;
            const confirmSecond = confirm("This will remove all rows. Confirm purge?");
            if (!confirmSecond) return;
            const payload = {
              source: "purge",
              imported_at: new Date().toISOString(),
              headers: dataStore[kind]?.headers || REQUIRED[kind] || [],
              rows: [],
            };
            const res = await apiFetch(`/api/files/${datasets[kind].file}`, {
              method: "PUT",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(payload),
            });
            if (res.status === 401) throw new Error("Please log in to purge");
            if (!res.ok) throw new Error(`Server returned ${res.status}`);
            dataStore[kind] = payload;
            renderTable(kind, payload.headers, payload.rows);
            setStatus(kind, "Purged all rows", true, "import");
            setStatus(kind, "Purged all rows", true, "logs");
            showPopup(`Purged ${kind} data`, true);
            renderDashboard();
          } catch (err) {
            showPopup(err.message || "Purge failed", false);
            setStatus(kind, err.message || "Purge failed", false, "import");
          }
        });
      });
    }

    async function restoreSessionIfPossible() {
      // Try to load data with an existing session; if successful, show the app.
      const loadedDiary = await fetchExisting("diary", { silentAuthFail: true });
      const loadedPain = await fetchExisting("pain", { silentAuthFail: true });
      const hasData = loadedDiary || loadedPain;
      setAppVisible(hasData);
      setAuthVisibility(hasData);
      if (hasData) {
        renderDashboard();
      }
    }

    function applyDateFilter(store, range = getDateRange()) {
      if (!store?.rows?.length) return store;
      const fromVal = range?.from instanceof Date ? range.from : null;
      const toVal = range?.to instanceof Date ? range.to : null;
      if (!fromVal && !toVal) return store;
      const filteredRows = store.rows.filter((row) => {
        const d = entryDateFromRow(row, store.headers);
        if (!d) return false;
        if (fromVal && d < fromVal) return false;
        if (toVal && d > toVal) return false;
        return true;
      });
      return { ...store, rows: filteredRows };
    }

    buildOptionCacheFromStore();
    renderPainOptionButtons();
    wireAuthForm();
    wireEntryTabs();
    wireAutotherapyTabs();
    wirePainForm();
    wireJournalForm();
    wireOptionEditors();
    wireDropZones();
    wireNav();
    wireExport();
    wirePurge();
    wireLogToggles();
    ["filter-from", "filter-to"].forEach((id) => {
      const el = document.getElementById(id);
      if (el) {
        el.addEventListener("change", () => {
          clearQuickActive();
          renderDashboard();
        });
      }
    });
    function applyQuickRange(range) {
      const fromInput = document.getElementById("filter-from");
      const toInput = document.getElementById("filter-to");
      const today = new Date();
      const toStr = today.toISOString().slice(0, 10);
      if (range === "all") {
        if (fromInput) fromInput.value = "";
        if (toInput) toInput.value = "";
      } else {
        const days = parseInt(range, 10);
        const from = new Date(today.getTime() - days * 24 * 60 * 60 * 1000);
        const fromStr = from.toISOString().slice(0, 10);
        if (fromInput) fromInput.value = fromStr;
        if (toInput) toInput.value = toStr;
      }
      const btn = document.querySelector(`.quick-btn[data-range="${range}"]`);
      if (btn) setQuickActive(btn);
      renderDashboard();
    }

    document.querySelectorAll(".quick-btn").forEach((btn) => {
      btn.addEventListener("click", () => {
        const range = btn.dataset.range;
        applyQuickRange(range);
      });
    });
    setAuthVisibility(false);
    setAppVisible(false);
    resetAppState();
    restoreSessionIfPossible();
    applyQuickRange("365");
  </script>
</body>
</html>
